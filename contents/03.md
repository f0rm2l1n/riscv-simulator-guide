# Spike ç¡¬ä»¶ä½“ç³»

> å³ä½¿å·²ç»é­”æ”¹äº†spikeå¥½ä¸€æ®µæ—¶é—´äº†ï¼Œä½†æ˜¯ä»ç„¶å¯¹æ•´ä¸ªå…¶æ¨¡æ‹Ÿçš„ç¡¬ä»¶ä½“ç³»å¾ˆæ¨¡ç³Š (ä¸ºå•¥ä¸å¼„ä¸ªå®˜æ–¹ä¸€ç‚¹çš„æ–‡æ¡£å‘¢ğŸ˜ª)ï¼›è¿™é‡Œç¨ä½œæ€»ç»“ï¼Œä¾›å¤§å®¶å‚è€ƒã€‚æ³¨æ„ç”±äºç¡¬ä»¶ç«¯çš„æ¨¡æ‹Ÿéƒ½åœ¨spikeä¸Šï¼Œæ­¤æ¬¡è®¨è®ºçš„ä»£ç æ ¹ç›®å½•ä¸º `riscv-isa-sim`ã€‚

## åˆ†è€Œæ²»ä¹‹
*ç”±äºæ•´ä¸ªspikeæ˜¯åŸºäº c++ 11 std å®Œæˆçš„ï¼Œå¹¶ä¸¥æ ¼éµå®ˆäº†é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼Œä¸ºäº†èƒ½å¤Ÿä¸åœ¨æºä»£ç è¿·å®«ä¸­æ’æ¥æ’å»ï¼Œæˆ‘ä»¬è¿˜æ˜¯å…ˆåˆ†å„ä¸ªæ¨¡å—æ¥ç†è§£å®ƒçš„å®ç°*

### Processor 
è¯´åˆ°ç¡¬ä»¶æ¨¡æ‹Ÿï¼Œå¤„ç†å™¨æ€»ä¼šæœ€å…ˆè¢«äººæƒ³åˆ°â€”â€”å¦‚ä½•è®¾è®¡çš„å¯„å­˜å™¨ï¼Ÿå¦‚ä½•å®ŒæˆæŒ‡ä»¤è¿ç®—ï¼Œç”šè‡³æ›´å¤æ‚ä¸€ç‚¹ï¼Œæœ‰æ²¡æœ‰å¯¹æµæ°´çº¿è¿›è¡Œæ¨¡æ‹Ÿï¼Ÿæˆ‘ä»¬å°†ä¸€ä¸€æ¢è®¨ã€‚

- å¤„ç†å™¨ç›¸å…³çš„ä»£ç ä½äº `riscv/processor.h` ä¸ `riscv/processor.cc`

æˆ‘ä»¬çœ‹åˆ°åä¸º*processor_t*çš„ç±»ï¼Œæ•´ä¸ªä»£ç æ¯”è¾ƒé•¿ï¼Œæˆ‘ä»¬å°†åˆ†å‡ æ®µæ¥åˆ†æ
```c++
// this class represents one processor in a RISC-V machine.
class processor_t : public abstract_device_t {
public:
    processor_t(const char* isa, const char* priv, const char* varch,
              simif_t* sim, uint32_t id, bool halt_on_reset=false);
    ~processor_t();
......
```
é¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œè¯¥ç±»ç»§æ‰¿ `abstrat_device_t` ç±»ï¼Œè¿™ä¸ªç±»å®ç°éå¸¸ç®€å•ï¼Œä»…ä»…æä¾›äº†åä¸º`load`å’Œ`store`çš„è™šå‡½æ•°ï¼Œå…·ä½“å®šä¹‰åœ¨`riscv/devices.h`ä¸­ã€‚

å†è€…ï¼Œå¯¹äºæ„é€ å‡½æ•°ï¼Œæˆ‘ä»¬åˆ†æå…¶ä¼ å…¥çš„å‚æ•°
- *const char\* isa*: æŒ‡ä»¤é›†ï¼Œé»˜è®¤ä¸º **RV64IMAFDC**ã€‚
- *const char\* priv*: ç‰¹æƒï¼Œé»˜è®¤æ˜¯ **MSU**ã€‚
- *const char\* varch*: vector å¯„å­˜å™¨çš„ç›¸å…³è®¾ç½®ï¼Œé»˜è®¤æ˜¯ **vlen:128,elen:64,slen:128**
- *simif_t\* sim*: simif_tç±»æŒ‡é’ˆï¼Œåé¢æ±‡æ€»åˆ†æ
- *uint32_t id*: è¯¥å¤„ç†å™¨çš„idï¼Œè‡ªç„¶ä¸ä¹‹å‰æ–‡ç« æ‰€æåˆ°çš„ mhardit ç›¸å…³
- *bool halt_on_reset*: æ˜¯å¦å¯åŠ¨æ—¶åœæ­¢ï¼Œç”¨äºè°ƒè¯•å™¨çš„è¿æ¥

wellï¼Œå†…å®¹å¹¶ä¸å¤šå“ˆï¼Œæˆ‘ä»¬æ¥ç€å…ˆåˆ†æä¸€ä¸‹æ„é€ å‡½æ•°çš„å†…å®¹

```c++
processor_t::processor_t(const char* isa, const char* priv, const char* varch,
                         simif_t* sim, uint32_t id, bool halt_on_reset)
  : debug(false), halt_request(false), sim(sim), ext(NULL), id(id), xlen(0),
  histogram_enabled(false), log_commits_enabled(false),
  halt_on_reset(halt_on_reset), last_pc(1), executions(1)
{
  VU.p = this;
  parse_isa_string(isa);
  parse_priv_string(priv);
  parse_varch_string(varch);
  register_base_instructions();
  mmu = new mmu_t(sim, this);

  disassembler = new disassembler_t(max_xlen);
  if (ext)
    for (auto disasm_insn : ext->get_disasms())
      disassembler->add_insn(disasm_insn);

  reset();
}
```
é‚£äº›ç›´æ¥è¿›è¡Œçš„èµ‹å€¼ä¹‹ä¸­æ¶‰åŠçš„æˆå‘˜å˜é‡ï¼Œæˆ‘ä»¬å°±åœ¨åé¢è®²è§£ã€‚è¿™é‡Œå¯ä»¥çœ‹åˆ°ï¼Œå‡½æ•°é¦–å…ˆè°ƒç”¨äº†ç›¸å…³çš„parseå‡½æ•°æ¥è®¾ç½®å¥½`isa`, `priv`ä»¥åŠ`varch`ã€‚éšä¹‹ï¼Œåœ¨`register_base_instructions()`ä¸­æ³¨å†Œäº†å¤„ç†å™¨å¯ä»¥æ‰§è¡Œçš„æŒ‡ä»¤ï¼›æ›´æœ‰è¶£çš„æ˜¯æˆ‘ä»¬çœ‹åˆ°äº†å¯¹`mmu_t`çš„åˆå§‹åŒ–ï¼Œè¿™ä¹Ÿè¡¨æ˜äº†åç»­æˆ‘ä»¬åˆ†æçš„å†…å­˜ç®¡ç†å•å…ƒ`mmu_t`çš„ç²’åº¦æ˜¯pre-processorçš„ã€‚

æœ‰è¶£çš„æ˜¯ï¼Œè¿™é‡Œè¿˜è®¾ç½®äº†åä¸º`disassembler`çš„æˆå‘˜ï¼Œæˆ‘ä»¬åç»­å†çœ‹çœ‹å®ƒå¹²äº†å•¥

æœ€åè°ƒç”¨`reset()`å‡½æ•°å®Œæˆå¯¹è®¸å¤šå¯„å­˜å™¨ä»¥åŠæ§åˆ¶å€¼çš„æ¸…é›¶ã€‚

> ç”±äºæˆ‘ä»¬è¿™é‡Œé‡åœ¨ä»çœ‹ç¡¬ä»¶çš„è§†è§’å»çœ‹å®ç°ï¼Œä¸€äº›ç»†èŠ‚å°±æš‚æ—¶çš„å¿½ç•¥æ‰äº†å“ˆï¼Œæ•´ä¸ªé€»è¾‘ä¸ä¸€å®šè¿è´¯

å¥½å•¦ï¼Œè½¬åˆ°è®¤çœŸçš„åˆ†æï¼Œè°ˆåˆ°risc-vå¤„ç†å™¨ï¼Œè®©äººæ„Ÿå…´è¶£çš„è‡ªç„¶å°±æ˜¯
1. å¯„å­˜å™¨
2. æŒ‡ä»¤æ‰§è¡Œ
3. ç‰¹æƒçº§åˆ«
è¿™æ ·çš„è¯é¢˜äº†ï¼Œæˆ‘ä»¬åˆ†ç€çœ‹çœ‹spikeçš„å®ç°

#### å¯„å­˜å™¨
æˆ‘ä»¬çœ‹åˆ°`processor_t`ç±»ä¸­ï¼Œæœ‰ä¸€ä¸ªåä¸º`state`çš„ç§æœ‰æˆå‘˜å˜é‡ï¼Œå…¶å£°æ˜å¦‚ä¸‹
```c++
// architectural state of a RISC-V hart
struct state_t
{
  void reset(reg_t max_isa);
  static const int num_triggers = 4;
  reg_t pc;
  regfile_t<reg_t, NXPR, true> XPR;
  regfile_t<freg_t, NFPR, false> FPR;
  // control and status registers
  reg_t prv;    // TODO: Can this be an enum instead?
  reg_t misa;
  reg_t mstatus;
  reg_t mepc;
.......
};
```
å“‡ï¼Œå°±æ„Ÿè§‰ä¸€å †å¯„å­˜å™¨ç”©åˆ°è„¸ä¸Šï¼Œè¿™ä¸ªç»“æ„ä½“æ‰¿è½½äº†æ‰€æœ‰çš„ï¼Œä¸å¤„ç†å™¨çŠ¶æ€ç›¸å…³çš„é‡;
- æ•´å‹å¯„å­˜å™¨
```c++
regfile_t<reg_t, NXPR, true> XPR;
```
å…¶ä¸­`regfile_t`æ˜¯æ¨¡æ¿ç±»å‹ï¼Œå…¶æ„é€ ä½¿ç”¨çš„`reg_t`ä¸ºè¾“å…¥ç»™è¯¥æ¨¡æ¿çš„ç±»å‹ï¼Œ`NXPR`è¡¨ç¤ºæ¨¡æ¿ç±»å•å…ƒçš„æ•°é‡ï¼Œ`true`è¡¨ç¤ºå­˜åœ¨é›¶å¯„å­˜å™¨ï¼›
ç®€å•çš„è¯´ï¼Œç”¨ä¸€ä¸ªæ•°ç»„æ¥ç†è§£å³å¯ã€‚

å¸¸é‡å’Œå®šä¹‰åœ¨`riscv/decode.h`ä¸­
```c++
const int NXPR = 32;
const int NFPR = 32;
const int NVPR = 32;
const int NCSR = 4096;
```

- æµ®ç‚¹å‹å¯„å­˜å™¨
```c++
regfile_t<freg_t, NFPR, false> FPR;
```
ä¸é‡å¤èµ˜è¿°äº†ã€‚æ³¨æ„åœ¨64ä½æ¶æ„ä¸‹ï¼Œ`freg_t`æ˜¯128ä½çš„float

- ç‰¹æƒå¯„å­˜å™¨å’Œå‘é‡å¯„å­˜å™¨
æ²¡æœ‰å®Œå…¨ç»Ÿè®¡ï¼Œä½†å¤šæ•°çš„ç‰¹æƒå¯„å­˜å™¨ä¹Ÿä½äº`state`ä¹‹ä¸­ï¼›ç‰¹æƒå¯„å­˜å™¨çš„ç»†èŠ‚è¿˜æ˜¯é˜…è¯»risc-vçš„privilegeæ‰‹å†Œï¼›
å‘é‡å¯„å­˜å™¨çš„è¯ï¼Œç”¨ä¸åˆ°å°±å…ˆä¸å»ç®¡äº†

#### æŒ‡ä»¤æ‰§è¡Œ
å¯„å­˜å™¨å°±ä»‹ç»ä»‹ç»æ”¾å“ªä¹Ÿè¿‡äºç²—ç³™äº†ï¼Œè‡ªç„¶ï¼Œå› ä¸ºå¯„å­˜å™¨æ— æ³•ç¦»å¼€æŒ‡ä»¤è€Œå­˜åœ¨ï¼Œæ‰€ä»¥è¦è®¨è®ºåˆ°æŒ‡ä»¤æ‰§è¡Œæ‰èƒ½åˆé€‚çš„äº†è§£å¯¹å¯„å­˜å™¨çš„ä½¿ç”¨ã€‚
å¼€é—¨è§å±±çš„è¯´ï¼Œæ‰€æœ‰çš„æŒ‡ä»¤çš„ä¸»è¦å®ç°éƒ½æ”¾ç½®äº`riscv/insns`æ–‡ä»¶å¤¹ä¸‹ï¼Œå¦‚æœæƒ³è‡ªå·±æ·»åŠ æŒ‡ä»¤ï¼Œå¤šæ•°æƒ…å†µä¸‹ä¾è‘«èŠ¦ç”»ç“¢å³å¯ã€‚
å¦‚ add æŒ‡ä»¤ï¼Œå¦‚ä¸‹
```c++
// riscv/insns/add.h
WRITE_RD(sext_xlen(RS1 + RS2));
```
é€»è¾‘ç›¸å½“ç®€å•ï¼Œå…¶ä¸­`WRITE_RD`ï¼Œ`RS1`ï¼Œ`RS2`å‡ä¸º`riscv/decode.h`ä¸­å®šä¹‰çš„å®ï¼Œç”¨äºè§£ææŒ‡ä»¤å­—æ®µå¹¶è®¿é—®ä¹‹å‰æˆ‘ä»¬è®¨è®ºè¿‡çš„æ•´å‹å¯„å­˜å™¨ã€‚

æˆ‘æƒ³ä½ å¯èƒ½ä¼šæœ‰ç–‘æƒ‘ï¼Œæ€ä¹ˆå°±ä¸€è¡Œä»£ç ï¼Ÿå’‹ç¼–è¯‘å‘¢ï¼Ÿ
å®é™…ä¸Šè¿™é‡Œå®ç°æ˜¯ä¸»ä½“å†…å®¹ï¼Œä»£ç å…·ä½“çš„å†…å®¹è¦ç»è¿‡åŠ å·¥ï¼Œæˆ‘ä»¬æŸ¥çœ‹ä»£ç çš„æ¨¡æ¿

```c++
// riscv/insn_template.h
// See LICENSE for license details.

#include "arith.h"
#include "mmu.h"
#include "softfloat.h"
#include "internals.h"
#include "specialize.h"
#include "tracer.h"
#include <assert.h>

/* ---------------------------------------- */
// riscv/insn_template.cc
// See LICENSE for license details.
#include "insn_template.h"

reg_t rv32_NAME(processor_t* p, insn_t insn, reg_t pc)
{
  int xlen = 32;
  reg_t npc = sext_xlen(pc + insn_length(OPCODE));
  #include "insns/NAME.h"
  trace_opcode(p, OPCODE, insn);
  return npc;
}

reg_t rv64_NAME(processor_t* p, insn_t insn, reg_t pc)
{
  int xlen = 64;
  reg_t npc = sext_xlen(pc + insn_length(OPCODE));
  #include "insns/NAME.h"
  trace_opcode(p, OPCODE, insn);
  return npc;
}
```
åœ¨å®é™…buildçš„è¿‡ç¨‹ï¼ŒMakefileå°†æå–è¿™äº›æŒ‡ä»¤å¤´æ–‡ä»¶åˆæˆå®é™…çš„ccæ–‡ä»¶ç”¨äºç¼–è¯‘ï¼Œè¿™æ˜¯éå¸¸èªæ˜çš„è®¾è®¡äº†ã€‚

æŒ‡ä»¤è®¾è®¡å¼„æ‡‚äº†ï¼Œä½†è¿˜ä¸çŸ¥é“å’‹è¿è¡Œæ¥ç€ï¼Œæˆ‘ä»¬å›åˆ°å¤„ç†å™¨çš„ä»£ç ä¹‹ä¸­ã€‚

æŒ‡ä»¤çš„æ‰§è¡Œï¼Œå…¶ä¸»ä½“å®ç°ç”±é€šç”¨å‡½æ•°`execute_insn`æ¥å®Œæˆ
```c++
static reg_t execute_insn(processor_t* p, reg_t pc, insn_fetch_t fetch)
{
  commit_log_stash_privilege(p);
  reg_t npc = fetch.func(p, fetch.insn, pc);    // <= è¿™é‡Œå®Œæˆäº†æŒ‡ä»¤çš„æ‰§è¡Œ
......
```
çœ‹æ ·å­æ‰§è¡Œå’Œåä¸º`fetch`çš„ï¼Œç±»å‹ä¸º`insn_fetch_t`è¿™ä¸€å‚æ•°æœ‰å…³ï¼Œé€šè¿‡æŸ¥çœ‹æºä»£ç å‘ç°å¯¹å…¶çš„è°ƒç”¨éƒ½ç”±`step()`å‡½æ•°å®Œæˆ

```c++
// fetch/decode/execute loop
void processor_t::step(size_t n)
{
    ......
```
è¯¥éƒ¨åˆ†ä»£ç ååˆ†å†—æ‚ï¼Œå¦‚å…¶æ³¨é‡Šæ‰€è¨€ï¼Œå…¶å®Œæˆä»£ç çš„fetchï¼Œdecodeå’Œæ‰§è¡Œå‡ ä¸ªæ­¥éª¤ï¼›å› ä¸ºæŒ‡ä»¤fetchè¿˜éœ€è¦äº†è§£å†…å­˜ç®¡ç†ï¼Œæˆ‘ä»¬è¿™é‡Œæš‚æ—¶å»¶ç¼“ã€‚ä¸»è¦çœ‹çœ‹ä»£ç çš„decodeä¸executeã€‚

ä¸å¦¨å€’ç€æ¥çœ‹ï¼Œé¦–å…ˆçœ‹çœ‹è¿™ä¸ª`insns_fetch_t`ç»“æ„ï¼Œå…¶å®šä¹‰åœ¨`riscv/mmu.h`ä¸­
```c++
struct insn_fetch_t
{
  insn_func_t func;
  insn_t insn;
};
```
è¯¥ç»“æ„ä½“ä¹‹ä¸­çš„`insn_t`æ˜¯ä¸€ä¸ªå·¨å¤§çš„ç»“æ„ä½“ï¼Œç”¨äºæè¿°æŒ‡ä»¤é›†ä¸‹æŒ‡ä»¤çš„æ„æˆï¼Œå¦‚æ€æ ·æå–è¿™ä¸ªæŒ‡ä»¤ä¹‹ä¸­çš„rdç­‰ï¼Œæå–opcodeç­‰ç­‰ï¼Œå£°æ˜åœ¨`riscv/decode.h`ä¹‹ä¸­ã€‚
è€Œè¿™é‡Œçš„æˆå‘˜`insn_func_t`ï¼Œå¦‚å…¶åï¼Œåº”è¯¥æ˜¯å¤„ç†è¿™ä¸ªæŒ‡ä»¤çš„å‡½æ•°çš„æŒ‡é’ˆï¼Œå…¶å®šä¹‰åœ¨`riscv/processor.h`ä¹‹ä¸­
```c++
typedef reg_t (*insn_func_t)(processor_t*, insn_t, reg_t);
```
æˆ–è®¸ä½ å·²ç»å‘ç°äº†ï¼Œè¿™ä¸ªå‡½æ•°çš„æ¨¡æ ·å’Œæˆ‘ä»¬å‰é¢ä¸¾ä¾‹å­`add`æ—¶æå‡ºçš„æ¨¡æ¿åŒå‡ºä¸€è¾™å‘€ï¼Œè¿™é‡Œå°±å›ç­”äº†å¦‚ä½•è”ç³»åˆ°æŒ‡é’ˆçš„å®ç°è¿™ä¸€ä¸ªé—®é¢˜ã€‚

å¦‚ä½•decodeå‘¢ï¼Ÿè™½ç„¶åœ¨æ²¡æœ‰åˆ†æfetchçš„æ—¶å€™åˆ†æè§£ç ä¼šæœ‰ç‚¹ç‰µå¼ºï¼Œæˆ‘ä»¬å°±ç®€å•çœ‹çœ‹ï¼›åœ¨æŒ‡ä»¤çš„fetchè¿‡ç¨‹ä¸­ï¼Œæœ‰è¿™æ ·ä¸€è¡Œä»£ç 
```c++
insn_fetch_t fetch = {proc->decode_insn(insn), insn};
```
å“ˆï¼Œæœ€ç»ˆè¿˜æ˜¯å›åˆ°äº†æˆ‘ä»¬çš„processor_tç±»ï¼Œæˆ‘ä»¬æ¥ç€åˆ†æä¸€ä¸‹è¿™çš„è§£ç å‡½æ•°
```c++
// insns/processor.cc
insn_func_t processor_t::decode_insn(insn_t insn)
{
  // look up opcode in hash table
  size_t idx = insn.bits() % OPCODE_CACHE_SIZE;
  insn_desc_t desc = opcode_cache[idx];
  if (unlikely(insn.bits() != desc.match)) {
    // fall back to linear search
    insn_desc_t* p = &instructions[0];
    while ((insn.bits() & p->mask) != p->match)
      p++;
    desc = *p;
    if (p->mask != 0 && p > &instructions[0]) {
      if (p->match != (p-1)->match && p->match != (p+1)->match) {
        // move to front of opcode list to reduce miss penalty
        while (--p >= &instructions[0])
          *(p+1) = *p;
        instructions[0] = desc;
      }
    }
    opcode_cache[idx] = desc;
    opcode_cache[idx].match = insn.bits();
  }
  return xlen == 64 ? desc.rv64 : desc.rv32;
}
```
ç®€å•çœ‹äº†çœ‹ä»£ç å°±å¯ä»¥å‘ç°ï¼Œå…³é”®æ˜¯ä¸€ä¸ªåä¸º`desc`çš„`insn_desc_t`ç±»å‹å˜é‡ï¼Œè€Œä¸”è¯¥å˜é‡ä¼¼ä¹æ˜¯é€šè¿‡å“ˆå¸Œè¡¨æ¥å¯»æ‰¾çš„ã€‚é¦–å…ˆäº†è§£ä¸€ä¸‹ç»“æ„ä½“
```c++
// riscv/processor.h
struct insn_desc_t
{
  insn_bits_t match;
  insn_bits_t mask;
  insn_func_t rv32;
  insn_func_t rv64;
};
```
å¦‚å…¶åï¼Œç»“æ„ä½“å­˜å‚¨ç€åˆ†åˆ«ç»™32ã€64ä½å¤„ç†çš„å‡½æ•°æŒ‡é’ˆï¼ˆè¿™é‡Œçš„matchä¸maskåœ¨ä¸Šä¸ªæåˆ°å‡½æ•°çš„å“ˆå¸Œè¡¨ä¹‹ä¸­è¢«ç”¨åˆ°)
åŒæ—¶å‘¢ï¼Œè¿™ä¸ªæœ‰è¶£çš„`opcode_cache`åˆ™æ˜¯åœ¨æœ€æœ€å¼€å§‹æˆ‘ä»¬æåŠçš„æ„é€ å‡½æ•°ä¸­çš„`register_base_instructions()`ä¸­çš„ç›¸å…³å‡½æ•°`build_opcode_map();`æ‰€å®Œæˆã€‚å…¶è¿‡ç¨‹æ˜¯é€šè¿‡å°†ç¼–è¯‘æ—¶äº§ç”Ÿçš„æŒ‡ä»¤åˆ—è¡¨ include åˆ°ä»£ç ä¸­å®Œæˆå„ä¸ªæŒ‡ä»¤çš„æ³¨å†Œæ¥å®ç°çš„ã€‚

#### ç‰¹æƒçº§åˆ«
é€šè¿‡é˜…è¯»risc-vçš„æ‰‹å†Œï¼Œæˆ‘ä»¬å¯ä»¥äº†è§£åˆ°risc-vçš„ç‰¹æƒè®¾è®¡
> æ™®é€šçš„æŒ‡ä»¤å³ç”¨æˆ·çš„ç¨‹åºå’Œè½¯ä»¶æ˜¯è¿è¡Œåœ¨æœ€ä½çš„ç”¨æˆ·æ¨¡å¼çš„ï¼Œè€Œå…¶ä»–ä¸¤ç§ç‰¹æƒæ¨¡å¼æ˜¯è¿è¡Œæœ€å¯ä¿¡ä»£ç çš„æœºå™¨æ¨¡å¼(machine code)ä¸ä¸ºåƒLinux, FreeBSDç­‰æ“ä½œç³»ç»Ÿæä¾›çš„ç›‘ç®¡è€…æ¨¡å¼(supervisor mode)

å¦‚ä½•å˜åŒ–ç‰¹æƒçº§ï¼å¬èµ·æ¥å¾ˆéš¾ï¼Œæ¯•ç«Ÿä¸åŒçš„ç‰¹æƒçº§æœ‰ç€ä¸åŒçš„è®¿é—®æƒé™å‘€ï¼

å¥½å§ï¼Œæ¯•ç«Ÿæ˜¯è½¯ä»¶æ¨¡æ‹Ÿï¼Œç‰¹æƒçº§çš„å˜åŒ–ä¸¤å¥è¯å°±æå®šäº†
```c++
// riscv/processor.cc
void processor_t::set_privilege(reg_t prv)
{
  mmu->flush_tlb();
  state.prv = legalize_privilege(prv);
}
```
å…¶ä¸­é¦–å…ˆå°†TLBç»™æ¸…ç©ºï¼Œç„¶å`legalize_privilege`å®ç°äº†ä¸€äº›æ£€æŸ¥ã€‚

åå‘çœ‹çœ‹å“ªå„¿è°ƒç”¨äº†è¿™äº›å‡½æ•°ï¼Œå®ç°æ˜¯é€šè¿‡åœ¨æŒ‡ä»¤æ‰§è¡Œè¿‡ç¨‹ä¸­å®Œæˆçš„trapçš„æ•è·å®Œæˆçš„

```c++
void processor_t::take_trap(trap_t& t, reg_t epc)
{
    ......
```
å…·ä½“çš„ä»£ç å°±ä¸åœ¨è¿™é‡Œåˆ†æäº†ï¼Œç®€å•è€Œè¨€ä»£ç å°†åœ¨è¿™é‡Œæ£€æŸ¥`trap`çš„åŸå› ï¼Œæ¥å†³å®šæ˜¯å¦éœ€è¦å®Œæˆç‰¹æƒçº§çš„è½¬åŒ–ï¼ˆè‡ªç„¶æœ‰ç‰¹æƒçº§åˆ«çš„å‡é«˜ä¹Ÿæœ‰ç‰¹æƒçº§åˆ«çš„é™ä½ï¼‰


### å­˜å‚¨
@TODO

### å…¶ä»–è®¾å¤‡
@TODO

## åˆè€Œå¾¡ä¹‹

