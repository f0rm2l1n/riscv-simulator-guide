# Spike ç¡¬ä»¶ä½“ç³»

> å³ä½¿å·²ç»é­”æ”¹äº†spikeå¥½ä¸€æ®µæ—¶é—´äº†ï¼Œä½†æ˜¯ä»ç„¶å¯¹æ•´ä¸ªå…¶æ¨¡æ‹Ÿçš„ç¡¬ä»¶ä½“ç³»å¾ˆæ¨¡ç³Š (ä¸ºå•¥ä¸å¼„ä¸ªå®˜æ–¹ä¸€ç‚¹çš„æ–‡æ¡£å‘¢ğŸ˜ª)ï¼›è¿™é‡Œç¨ä½œæ€»ç»“ï¼Œä¾›å¤§å®¶å‚è€ƒã€‚æ³¨æ„ç”±äºç¡¬ä»¶ç«¯çš„æ¨¡æ‹Ÿéƒ½åœ¨spikeä¸Šï¼Œæ­¤æ¬¡è®¨è®ºçš„ä»£ç æ ¹ç›®å½•ä¸º `riscv-isa-sim`ã€‚

## åˆ†è€Œæ²»ä¹‹
*ç”±äºæ•´ä¸ªspikeæ˜¯åŸºäº c++ 11 std å®Œæˆçš„ï¼Œå¹¶ä¸¥æ ¼éµå®ˆäº†é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼Œä¸ºäº†èƒ½å¤Ÿä¸åœ¨æºä»£ç è¿·å®«ä¸­æ’æ¥æ’å»ï¼Œæˆ‘ä»¬è¿˜æ˜¯å…ˆåˆ†å„ä¸ªæ¨¡å—æ¥ç†è§£å®ƒçš„å®ç°*

### Processor 
è¯´åˆ°ç¡¬ä»¶æ¨¡æ‹Ÿï¼Œå¤„ç†å™¨æ€»ä¼šæœ€å…ˆè¢«äººæƒ³åˆ°â€”â€”å¦‚ä½•è®¾è®¡çš„å¯„å­˜å™¨ï¼Ÿå¦‚ä½•å®ŒæˆæŒ‡ä»¤è¿ç®—ï¼Œç”šè‡³æ›´å¤æ‚ä¸€ç‚¹ï¼Œæœ‰æ²¡æœ‰å¯¹æµæ°´çº¿è¿›è¡Œæ¨¡æ‹Ÿï¼Ÿæˆ‘ä»¬å°†ä¸€ä¸€æ¢è®¨ã€‚

- å¤„ç†å™¨ç›¸å…³çš„ä»£ç ä½äº `riscv/processor.h` ä¸ `riscv/processor.cc`

æˆ‘ä»¬çœ‹åˆ°åä¸º*processor_t*çš„ç±»ï¼Œæ•´ä¸ªä»£ç æ¯”è¾ƒé•¿ï¼Œæˆ‘ä»¬å°†åˆ†å‡ æ®µæ¥åˆ†æ
```c++
// this class represents one processor in a RISC-V machine.
class processor_t : public abstract_device_t {
public:
    processor_t(const char* isa, const char* priv, const char* varch,
              simif_t* sim, uint32_t id, bool halt_on_reset=false);
    ~processor_t();
......
```
é¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œè¯¥ç±»ç»§æ‰¿ `abstrat_device_t` ç±»ï¼Œè¿™ä¸ªç±»å®ç°éå¸¸ç®€å•ï¼Œä»…ä»…æä¾›äº†åä¸º`load`å’Œ`store`çš„è™šå‡½æ•°ï¼Œå…·ä½“å®šä¹‰åœ¨`riscv/devices.h`ä¸­ã€‚

å†è€…ï¼Œå¯¹äºæ„é€ å‡½æ•°ï¼Œæˆ‘ä»¬åˆ†æå…¶ä¼ å…¥çš„å‚æ•°
- *const char\* isa*: æŒ‡ä»¤é›†ï¼Œé»˜è®¤ä¸º **RV64IMAFDC**ã€‚
- *const char\* priv*: ç‰¹æƒï¼Œé»˜è®¤æ˜¯ **MSU**ã€‚
- *const char\* varch*: vector å¯„å­˜å™¨çš„ç›¸å…³è®¾ç½®ï¼Œé»˜è®¤æ˜¯ **vlen:128,elen:64,slen:128**
- *simif_t\* sim*: simif_tç±»æŒ‡é’ˆï¼Œåé¢æ±‡æ€»åˆ†æ
- *uint32_t id*: è¯¥å¤„ç†å™¨çš„idï¼Œè‡ªç„¶ä¸ä¹‹å‰æ–‡ç« æ‰€æåˆ°çš„ mhardit ç›¸å…³
- *bool halt_on_reset*: æ˜¯å¦å¯åŠ¨æ—¶åœæ­¢ï¼Œç”¨äºè°ƒè¯•å™¨çš„è¿æ¥

wellï¼Œå†…å®¹å¹¶ä¸å¤šå“ˆï¼Œæˆ‘ä»¬æ¥ç€å…ˆåˆ†æä¸€ä¸‹æ„é€ å‡½æ•°çš„å†…å®¹

```c++
processor_t::processor_t(const char* isa, const char* priv, const char* varch,
                         simif_t* sim, uint32_t id, bool halt_on_reset)
  : debug(false), halt_request(false), sim(sim), ext(NULL), id(id), xlen(0),
  histogram_enabled(false), log_commits_enabled(false),
  halt_on_reset(halt_on_reset), last_pc(1), executions(1)
{
  VU.p = this;
  parse_isa_string(isa);
  parse_priv_string(priv);
  parse_varch_string(varch);
  ç­‰çš„æ¥å£ï¼›æˆ‘ä»¬æ¥çœ‹çœ‹å…¶æ–¹æ³•çš„å…·ä½“å®ç°ã€‚
  
  ```
  bcd_t::bcd_t()
{
  register_command(0, std::bind(&bcd_t::handle_read, this, _1), "read");
  register_command(1, std::bind(&bcd_t::handle_write, this, _1), "write");
}

void bcd_t::handle_read(command_t cmd)
{
  pending_reads.push(cmd);
}

void bcd_t::handle_write(command_t cmd)
{
  canonical_terminal_t::write(cmd.payload());
}

void bcd_t::tick()
{
  int ch;
  if (!pending_reads.empty() && (ch = canonical_terminal_t::read()) != -1)
  {
    pending_reads.front().respond(0x100 | ch);
    pending_reads.pop();
  }
}
  ```ister_base_instructions();
  mmu = new mmu_t(sim, this);

  disassembler = new disassembler_t(max_xlen);
  if (ext)
    for (auto disasm_insn : ext->get_disasms())
      disassembler->add_insn(disasm_insn);

  reset();
}
```
é‚£äº›ç›´æ¥è¿›è¡Œçš„èµ‹å€¼ä¹‹ä¸­æ¶‰åŠçš„æˆå‘˜å˜é‡ï¼Œæˆ‘ä»¬å°±åœ¨åé¢è®²è§£ã€‚è¿™é‡Œå¯ä»¥çœ‹åˆ°ï¼Œå‡½æ•°é¦–å…ˆè°ƒç”¨äº†ç›¸å…³çš„parseå‡½æ•°æ¥è®¾ç½®å¥½`isa`, `priv`ä»¥åŠ`varch`ã€‚éšä¹‹ï¼Œåœ¨`register_base_instructions()`ä¸­æ³¨å†Œäº†å¤„ç†å™¨å¯ä»¥æ‰§è¡Œçš„æŒ‡ä»¤ï¼›æ›´æœ‰è¶£çš„æ˜¯æˆ‘ä»¬çœ‹åˆ°äº†å¯¹`mmu_t`çš„åˆå§‹åŒ–ï¼Œè¿™ä¹Ÿè¡¨æ˜äº†åç»­æˆ‘ä»¬åˆ†æçš„å†…å­˜ç®¡ç†å•å…ƒ`mmu_t`çš„ç²’åº¦æ˜¯pre-processorçš„ã€‚

æœ‰è¶£çš„æ˜¯ï¼Œè¿™é‡Œè¿˜è®¾ç½®äº†åä¸º`disassembler`çš„æˆå‘˜ï¼Œæˆ‘ä»¬åç»­å†çœ‹çœ‹å®ƒå¹²äº†å•¥

æœ€åè°ƒç”¨`reset()`å‡½æ•°å®Œæˆå¯¹è®¸å¤šå¯„å­˜å™¨ä»¥åŠæ§åˆ¶å€¼çš„æ¸…é›¶ã€‚

> ç”±äºæˆ‘ä»¬è¿™é‡Œé‡åœ¨ä»çœ‹ç¡¬ä»¶çš„è§†è§’å»çœ‹å®ç°ï¼Œä¸€äº›ç»†èŠ‚å°±æš‚æ—¶çš„å¿½ç•¥æ‰äº†å“ˆï¼Œæ•´ä¸ªé€»è¾‘ä¸ä¸€å®šè¿è´¯

å¥½å•¦ï¼Œè½¬åˆ°è®¤çœŸçš„åˆ†æï¼Œè°ˆåˆ°risc-vå¤„ç†å™¨ï¼Œè®©äººæ„Ÿå…´è¶£çš„è‡ªç„¶å°±æ˜¯
1. å¯„å­˜å™¨
2. æŒ‡ä»¤æ‰§è¡Œ
3. ç‰¹æƒçº§åˆ«
è¿™æ ·çš„è¯é¢˜äº†ï¼Œæˆ‘ä»¬åˆ†ç€çœ‹çœ‹spikeçš„å®ç°

#### å¯„å­˜å™¨
æˆ‘ä»¬çœ‹åˆ°`processor_t`ç±»ä¸­ï¼Œæœ‰ä¸€ä¸ªåä¸º`state`çš„ç§æœ‰æˆå‘˜å˜é‡ï¼Œå…¶å£°æ˜å¦‚ä¸‹
```c++
// architectural state of a RISC-V hart
struct state_t
{
  void reset(reg_t max_isa);
  static const int num_triggers = 4;
  reg_t pc;
  regfile_t<reg_t, NXPR, true> XPR;
  regfile_t<freg_t, NFPR, false> FPR;
  // control and status registers
  reg_t prv;    // TODO: Can this be an enum instead?
  reg_t misa;
  reg_t mstatus;
  reg_t mepc;
.......
};
```
å“‡ï¼Œå°±æ„Ÿè§‰ä¸€å †å¯„å­˜å™¨ç”©åˆ°è„¸ä¸Šï¼Œè¿™ä¸ªç»“æ„ä½“æ‰¿è½½äº†æ‰€æœ‰çš„ï¼Œä¸å¤„ç†å™¨çŠ¶æ€ç›¸å…³çš„é‡;
- æ•´å‹å¯„å­˜å™¨
```c++
regfile_t<reg_t, NXPR, true> XPR;
```
å…¶ä¸­`regfile_t`æ˜¯æ¨¡æ¿ç±»å‹ï¼Œå…¶æ„é€ ä½¿ç”¨çš„`reg_t`ä¸ºè¾“å…¥ç»™è¯¥æ¨¡æ¿çš„ç±»å‹ï¼Œ`NXPR`è¡¨ç¤ºæ¨¡æ¿ç±»å•å…ƒçš„æ•°é‡ï¼Œ`true`è¡¨ç¤ºå­˜åœ¨é›¶å¯„å­˜å™¨ï¼›
ç®€å•çš„è¯´ï¼Œç”¨ä¸€ä¸ªæ•°ç»„æ¥ç†è§£å³å¯ã€‚

å¸¸é‡å’Œå®šä¹‰åœ¨`riscv/decode.h`ä¸­
```c++
const int NXPR = 32;
const int NFPR = 32;
const int NVPR = 32;
const int NCSR = 4096;
```

- æµ®ç‚¹å‹å¯„å­˜å™¨
```c++
regfile_t<freg_t, NFPR, false> FPR;
```
ä¸é‡å¤èµ˜è¿°äº†ã€‚æ³¨æ„åœ¨64ä½æ¶æ„ä¸‹ï¼Œ`freg_t`æ˜¯128ä½çš„float

- ç‰¹æƒå¯„å­˜å™¨å’Œå‘é‡å¯„å­˜å™¨
æ²¡æœ‰å®Œå…¨ç»Ÿè®¡ï¼Œä½†å¤šæ•°çš„ç‰¹æƒå¯„å­˜å™¨ä¹Ÿä½äº`state`ä¹‹ä¸­ï¼›ç‰¹æƒå¯„å­˜å™¨çš„ç»†èŠ‚è¿˜æ˜¯é˜…è¯»risc-vçš„privilegeæ‰‹å†Œï¼›
å‘é‡å¯„å­˜å™¨çš„è¯ï¼Œç”¨ä¸åˆ°å°±å…ˆä¸å»ç®¡äº†

#### æŒ‡ä»¤æ‰§è¡Œ
å¯„å­˜å™¨å°±ä»‹ç»ä»‹ç»æ”¾å“ªä¹Ÿè¿‡äºç²—ç³™äº†ï¼Œè‡ªç„¶ï¼Œå› ä¸ºå¯„å­˜å™¨æ— æ³•ç¦»å¼€æŒ‡ä»¤è€Œå­˜åœ¨ï¼Œæ‰€ä»¥è¦è®¨è®ºåˆ°æŒ‡ä»¤æ‰§è¡Œæ‰èƒ½åˆé€‚çš„äº†è§£å¯¹å¯„å­˜å™¨çš„ä½¿ç”¨ã€‚
å¼€é—¨è§å±±çš„è¯´ï¼Œæ‰€æœ‰çš„æŒ‡ä»¤çš„ä¸»è¦å®ç°éƒ½æ”¾ç½®äº`riscv/insns`æ–‡ä»¶å¤¹ä¸‹ï¼Œå¦‚æœæƒ³è‡ªå·±æ·»åŠ æŒ‡ä»¤ï¼Œå¤šæ•°æƒ…å†µä¸‹ä¾è‘«èŠ¦ç”»ç“¢å³å¯ã€‚
å¦‚ add æŒ‡ä»¤ï¼Œå¦‚ä¸‹
```c++
// riscv/insns/add.h
WRITE_RD(sext_xlen(RS1 + RS2));
```
é€»è¾‘ç›¸å½“ç®€å•ï¼Œå…¶ä¸­`WRITE_RD`ï¼Œ`RS1`ï¼Œ`RS2`å‡ä¸º`riscv/decode.h`ä¸­å®šä¹‰çš„å®ï¼Œç”¨äºè§£ææŒ‡ä»¤å­—æ®µå¹¶è®¿é—®ä¹‹å‰æˆ‘ä»¬è®¨è®ºè¿‡çš„æ•´å‹å¯„å­˜å™¨ã€‚

æˆ‘æƒ³ä½ å¯èƒ½ä¼šæœ‰ç–‘æƒ‘ï¼Œæ€ä¹ˆå°±ä¸€è¡Œä»£ç ï¼Ÿå’‹ç¼–è¯‘å‘¢ï¼Ÿ
å®é™…ä¸Šè¿™é‡Œå®ç°æ˜¯ä¸»ä½“å†…å®¹ï¼Œä»£ç å…·ä½“çš„å†…å®¹è¦ç»è¿‡åŠ å·¥ï¼Œæˆ‘ä»¬æŸ¥çœ‹ä»£ç çš„æ¨¡æ¿

```c++
// riscv/insn_template.h
// See LICENSE for license details.

#include "arith.h"
#include "mmu.h"
#include "softfloat.h"
#include "internals.h"
#include "specialize.h"
#include "tracer.h"
#include <assert.h>

/* ---------------------------------------- */
// riscv/insn_template.cc
// See LICENSE for license details.
#include "insn_template.h"

reg_t rv32_NAME(processor_t* p, insn_t insn, reg_t pc)
{
  int xlen = 32;
  reg_t npc = sext_xlen(pc + insn_length(OPCODE));
  #include "insns/NAME.h"
  trace_opcode(p, OPCODE, insn);
  return npc;
}

reg_t rv64_NAME(processor_t* p, insn_t insn, reg_t pc)
{
  int xlen = 64;
  reg_t npc = sext_xlen(pc + insn_length(OPCODE));
  #include "insns/NAME.h"
  trace_opcode(p, OPCODE, insn);
  return npc;
}
```
åœ¨å®é™…buildçš„è¿‡ç¨‹ï¼ŒMakefileå°†æå–è¿™äº›æŒ‡ä»¤å¤´æ–‡ä»¶åˆæˆå®é™…çš„ccæ–‡ä»¶ç”¨äºç¼–è¯‘ï¼Œè¿™æ˜¯éå¸¸èªæ˜çš„è®¾è®¡äº†ã€‚

æŒ‡ä»¤è®¾è®¡å¼„æ‡‚äº†ï¼Œä½†è¿˜ä¸çŸ¥é“å’‹è¿è¡Œæ¥ç€ï¼Œæˆ‘ä»¬å›åˆ°å¤„ç†å™¨çš„ä»£ç ä¹‹ä¸­ã€‚

æŒ‡ä»¤çš„æ‰§è¡Œï¼Œå…¶ä¸»ä½“å®ç°ç”±é€šç”¨å‡½æ•°`execute_insn`æ¥å®Œæˆ
```c++
static reg_t execute_insn(processor_t* p, reg_t pc, insn_fetch_t fetch)
{
  commit_log_stash_privilege(p);
  reg_t npc = fetch.func(p, fetch.insn, pc);    // <= è¿™é‡Œå®Œæˆäº†æŒ‡ä»¤çš„æ‰§è¡Œ
......
```
çœ‹æ ·å­æ‰§è¡Œå’Œåä¸º`fetch`çš„ï¼Œç±»å‹ä¸º`insn_fetch_t`è¿™ä¸€å‚æ•°æœ‰å…³ï¼Œé€šè¿‡æŸ¥çœ‹æºä»£ç å‘ç°å¯¹å…¶çš„è°ƒç”¨éƒ½ç”±`step()`å‡½æ•°å®Œæˆ

```c++
// fetch/decode/execute loop
void processor_t::step(size_t n)
{
    ......
```
è¯¥éƒ¨åˆ†ä»£ç ååˆ†å†—æ‚ï¼Œå¦‚å…¶æ³¨é‡Šæ‰€è¨€ï¼Œå…¶å®Œæˆä»£ç çš„fetchï¼Œdecodeå’Œæ‰§è¡Œå‡ ä¸ªæ­¥éª¤ï¼›å› ä¸ºæŒ‡ä»¤fetchè¿˜éœ€è¦äº†è§£å†…å­˜ç®¡ç†ï¼Œæˆ‘ä»¬è¿™é‡Œæš‚æ—¶å»¶ç¼“ã€‚ä¸»è¦çœ‹çœ‹ä»£ç çš„decodeä¸executeã€‚

ä¸å¦¨å€’ç€æ¥çœ‹ï¼Œé¦–å…ˆçœ‹çœ‹è¿™ä¸ª`insns_fetch_t`ç»“æ„ï¼Œå…¶å®šä¹‰åœ¨`riscv/mmu.h`ä¸­
```c++
struct insn_fetch_t
{
  insn_func_t func;
  insn_t insn;
};
```
è¯¥ç»“æ„ä½“ä¹‹ä¸­çš„`insn_t`æ˜¯ä¸€ä¸ªå·¨å¤§çš„ç»“æ„ä½“ï¼Œç”¨äºæè¿°æŒ‡ä»¤é›†ä¸‹æŒ‡ä»¤çš„æ„æˆï¼Œå¦‚æ€æ ·æå–è¿™ä¸ªæŒ‡ä»¤ä¹‹ä¸­çš„rdç­‰ï¼Œæå–opcodeç­‰ç­‰ï¼Œå£°æ˜åœ¨`riscv/decode.h`ä¹‹ä¸­ã€‚
è€Œè¿™é‡Œçš„æˆå‘˜`insn_func_t`ï¼Œå¦‚å…¶åï¼Œåº”è¯¥æ˜¯å¤„ç†è¿™ä¸ªæŒ‡ä»¤çš„å‡½æ•°çš„æŒ‡é’ˆï¼Œå…¶å®šä¹‰åœ¨`riscv/processor.h`ä¹‹ä¸­
```c++
typedef reg_t (*insn_func_t)(processor_t*, insn_t, reg_t);
```
æˆ–è®¸ä½ å·²ç»å‘ç°äº†ï¼Œè¿™ä¸ªå‡½æ•°çš„æ¨¡æ ·å’Œæˆ‘ä»¬å‰é¢ä¸¾ä¾‹å­`add`æ—¶æå‡ºçš„æ¨¡æ¿åŒå‡ºä¸€è¾™å‘€ï¼Œè¿™é‡Œå°±å›ç­”äº†å¦‚ä½•è”ç³»åˆ°æŒ‡é’ˆçš„å®ç°è¿™ä¸€ä¸ªé—®é¢˜ã€‚

å¦‚ä½•decodeå‘¢ï¼Ÿè™½ç„¶åœ¨æ²¡æœ‰åˆ†æfetchçš„æ—¶å€™åˆ†æè§£ç ä¼šæœ‰ç‚¹ç‰µå¼ºï¼Œæˆ‘ä»¬å°±ç®€å•çœ‹çœ‹ï¼›åœ¨æŒ‡ä»¤çš„fetchè¿‡ç¨‹ä¸­ï¼Œæœ‰è¿™æ ·ä¸€è¡Œä»£ç 
```c++
insn_fetch_t fetch = {proc->decode_insn(insn), insn};
```
å“ˆï¼Œæœ€ç»ˆè¿˜æ˜¯å›åˆ°äº†æˆ‘ä»¬çš„processor_tç±»ï¼Œæˆ‘ä»¬æ¥ç€åˆ†æä¸€ä¸‹è¿™çš„è§£ç å‡½æ•°
```c++
// insns/processor.cc
insn_func_t processor_t::decode_insn(insn_t insn)
{
  // look up opcode in hash table
  size_t idx = insn.bits() % OPCODE_CACHE_SIZE;
  insn_desc_t desc = opcode_cache[idx];
  if (unlikely(insn.bits() != desc.match)) {
    // fall back to linear search
    insn_desc_t* p = &instructions[0];
    while ((insn.bits() & p->mask) != p->match)
      p++;
    desc = *p;
    if (p->mask != 0 && p > &instructions[0]) {
      if (p->match != (p-1)->match && p->match != (p+1)->match) {
        // move to front of opcode list to reduce miss penalty
        while (--p >= &instructions[0])
          *(p+1) = *p;
        instructions[0] = desc;
      }
    }
    opcode_cache[idx] = desc;
    opcode_cache[idx].match = insn.bits();
  }
  return xlen == 64 ? desc.rv64 : desc.rv32;
}
```
ç®€å•çœ‹äº†çœ‹ä»£ç å°±å¯ä»¥å‘ç°ï¼Œå…³é”®æ˜¯ä¸€ä¸ªåä¸º`desc`çš„`insn_desc_t`ç±»å‹å˜é‡ï¼Œè€Œä¸”è¯¥å˜é‡ä¼¼ä¹æ˜¯é€šè¿‡å“ˆå¸Œè¡¨æ¥å¯»æ‰¾çš„ã€‚é¦–å…ˆäº†è§£ä¸€ä¸‹ç»“æ„ä½“
```c++
// riscv/processor.h
struct insn_desc_t
{
  insn_bits_t match;
  insn_bits_t mask;
  insn_func_t rv32;
  insn_func_t rv64;
};
```
å¦‚å…¶åï¼Œç»“æ„ä½“å­˜å‚¨ç€åˆ†åˆ«ç»™32ã€64ä½å¤„ç†çš„å‡½æ•°æŒ‡é’ˆï¼ˆè¿™é‡Œçš„matchä¸maskåœ¨ä¸Šä¸ªæåˆ°å‡½æ•°çš„å“ˆå¸Œè¡¨ä¹‹ä¸­è¢«ç”¨åˆ°)
åŒæ—¶å‘¢ï¼Œè¿™ä¸ªæœ‰è¶£çš„`opcode_cache`åˆ™æ˜¯åœ¨æœ€æœ€å¼€å§‹æˆ‘ä»¬æåŠçš„æ„é€ å‡½æ•°ä¸­çš„`register_base_instructions()`ä¸­çš„ç›¸å…³å‡½æ•°`build_opcode_map();`æ‰€å®Œæˆã€‚å…¶è¿‡ç¨‹æ˜¯é€šè¿‡å°†ç¼–è¯‘æ—¶äº§ç”Ÿçš„æŒ‡ä»¤åˆ—è¡¨ include åˆ°ä»£ç ä¸­å®Œæˆå„ä¸ªæŒ‡ä»¤çš„æ³¨å†Œæ¥å®ç°çš„ã€‚

#### ç‰¹æƒçº§åˆ«
é€šè¿‡é˜…è¯»risc-vçš„æ‰‹å†Œï¼Œæˆ‘ä»¬å¯ä»¥äº†è§£åˆ°risc-vçš„ç‰¹æƒè®¾è®¡
> æ™®é€šçš„æŒ‡ä»¤å³ç”¨æˆ·çš„ç¨‹åºå’Œè½¯ä»¶æ˜¯è¿è¡Œåœ¨æœ€ä½çš„ç”¨æˆ·æ¨¡å¼çš„ï¼Œè€Œå…¶ä»–ä¸¤ç§ç‰¹æƒæ¨¡å¼æ˜¯è¿è¡Œæœ€å¯ä¿¡ä»£ç çš„æœºå™¨æ¨¡å¼(machine code)ä¸ä¸ºåƒLinux, FreeBSDç­‰æ“ä½œç³»ç»Ÿæä¾›çš„ç›‘ç®¡è€…æ¨¡å¼(supervisor mode)

å¦‚ä½•å˜åŒ–ç‰¹æƒçº§ï¼å¬èµ·æ¥å¾ˆéš¾ï¼Œæ¯•ç«Ÿä¸åŒçš„ç‰¹æƒçº§æœ‰ç€ä¸åŒçš„è®¿é—®æƒé™å‘€ï¼

å¥½å§ï¼Œæ¯•ç«Ÿæ˜¯è½¯ä»¶æ¨¡æ‹Ÿï¼Œç‰¹æƒçº§çš„å˜åŒ–ä¸¤å¥è¯å°±æå®šäº†
```c++
// riscv/processor.cc
void processor_t::set_privilege(reg_t prv)
{
  mmu->flush_tlb();
  state.prv = legalize_privilege(prv);
}
```
å…¶ä¸­é¦–å…ˆå°†TLBç»™æ¸…ç©ºï¼Œç„¶å`legalize_privilege`å®ç°äº†ä¸€äº›æ£€æŸ¥ã€‚

åå‘çœ‹çœ‹å“ªå„¿è°ƒç”¨äº†è¿™äº›å‡½æ•°ï¼Œå®ç°æ˜¯é€šè¿‡åœ¨æŒ‡ä»¤æ‰§è¡Œè¿‡ç¨‹ä¸­å®Œæˆçš„trapçš„æ•è·å®Œæˆçš„

```c++
void processor_t::take_trap(trap_t& t, reg_t epc)
{
    ......
```
å…·ä½“çš„ä»£ç å°±ä¸åœ¨è¿™é‡Œåˆ†æäº†ï¼Œç®€å•è€Œè¨€ä»£ç å°†åœ¨è¿™é‡Œæ£€æŸ¥`trap`çš„åŸå› ï¼Œæ¥å†³å®šæ˜¯å¦éœ€è¦å®Œæˆç‰¹æƒçº§çš„è½¬åŒ–ï¼ˆè‡ªç„¶æœ‰ç‰¹æƒçº§åˆ«çš„å‡é«˜ä¹Ÿæœ‰ç‰¹æƒçº§åˆ«çš„é™ä½ï¼‰


### å­˜å‚¨
ä¹‹å‰åšç³»ç»Ÿç›¸å…³çš„å®éªŒçš„æ—¶å€™ï¼Œç ”ç©¶ARMç›¸å…³çš„æ‰‹å†Œï¼Œå…¶ä¸­æ€æ ·åšmappingï¼Œæ€æ ·ç®¡ç†å†…å­˜éƒ½æ˜¯å¾ˆé‡è¦çš„ã€‚å‰é¢æˆ‘ä»¬ä¹Ÿæåˆ°äº†å¤„ç†å™¨`processor_t`åœ¨æ„é€ å‡½æ•°æ—¶ä¼šå®Œæˆå¯¹äºåä¸º`mmu_t`å•å…ƒçš„åˆå§‹åŒ–ï¼Œé‚£ä¹ˆè¿™é‡Œæˆ‘ä»¬å°±å…ˆçœ‹çœ‹è¿™ä¸ª MMU (Memory Management Unit)

```c++
// riscv/mmu.h
// this class implements a processor's port into the virtual memory system.
// an MMU and instruction cache are maintained for simulator performance.
class mmu_t
{
public:
    mmu_t(simif_t* sim, processor_t* proc);
    ~mmu_t();
```
> æ³¨é‡Šé‡Œé¢æ€»ä¼šæœ‰å…·æœ‰ä»·å€¼çš„ä¿¡æ¯ï¼Œè¿™é‡Œè¯´æ˜äº†spikeå®ç°äº†æŒ‡ä»¤å±‚æ¬¡çš„cacheä»¥ç”¨äºåŠ é€Ÿ

è¿˜æ˜¯å’Œä¹‹å‰ä¸€æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆçœ‹ä¸€ä¸‹å…¶æ„é€ å‡½æ•°

```c++
mmu_t::mmu_t(simif_t* sim, processor_t* proc)
 : sim(sim), proc(proc),
  check_triggers_fetch(false),
  check_triggers_load(false),
  check_triggers_store(false),
  matched_trigger(NULL)
{
  flush_tlb();
  yield_load_reservation();
}
```

éå¸¸ç®€å•å¹²ç»ƒçš„æ„é€ å‡½æ•°ï¼Œå®Œæˆäº†æˆå‘˜å˜é‡çš„èµ‹å€¼ä¹‹åå°±æ¸…ç©ºTLBï¼Œç„¶åæœ‰ä¸€ä¸ªåä¸º`yield_load_reservation`çš„å‡½æ•°ï¼Œæˆ‘ä»¬ç•™ç»™åé¢å»åˆ†æ
æ•´ä½“æ¥è¯´ï¼Œå¯¹äºMMUæˆ‘ä»¬å…³å¿ƒçš„æ˜¯
1. load
2. store 
3. fetchå’ŒæŒ‡ä»¤ icache
å½“ç„¶ï¼Œ(1)åŒ…æ‹¬äº†æˆ‘ä»¬æ¯”è¾ƒå…³å¿ƒçš„åœ°å€çš„æ˜ å°„è¿‡ç¨‹ï¼Œæˆ‘ä»¬å°±å…ˆä»`load`è®²èµ·

#### LOAD
æŸ¥çœ‹æ±‡ç¼–æŒ‡ä»¤`ld, lw, lh, lb`çš„å®ç°ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°ä»¥ä¸‹å†…å®¹
```c++
WRITE_RD(MMU.load_int64(RS1 + insn.i_imm()));   // ld
WRITE_RD(MMU.load_int32(RS1 + insn.i_imm()));   // lw
WRITE_RD(MMU.load_int16(RS1 + insn.i_imm()));   // lh
WRITE_RD(MMU.load_int8(RS1 + insn.i_imm()));    // lb
```
ä¸€ç›®äº†ç„¶ï¼ŒMMUä¸­çš„`load_xxxx`å‡½æ•°æ˜¯ç”¨äºè®¿é—®è™šæ‹Ÿå†…å­˜çš„æ¥å£ï¼Œè€Œå…¶å®ç°ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨`riscv/mmu.h`ä¸­æ‰¾åˆ°
```c++
// template for functions that load an aligned value from memory
  #define load_func(type) \
    inline type##_t load_##type(reg_t addr) { \
      if (unlikely(addr & (sizeof(type##_t)-1))) \
        return misaligned_load(addr, sizeof(type##_t)); \
      reg_t vpn = addr >> PGSHIFT; \
      size_t size = sizeof(type##_t); \
      if (likely(tlb_load_tag[vpn % TLB_ENTRIES] == vpn)) { \
        if (proc) READ_MEM(addr, size); \
        return from_le(*(type##_t*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr)); \
      } \
      if (unlikely(tlb_load_tag[vpn % TLB_ENTRIES] == (vpn | TLB_CHECK_TRIGGERS))) { \
        type##_t data = from_le(*(type##_t*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr)); \
        if (!matched_trigger) { \
          matched_trigger = trigger_exception(OPERATION_LOAD, addr, data); \
          if (matched_trigger) \
            throw *matched_trigger; \
        } \
        if (proc) READ_MEM(addr, size); \
        return data; \
      } \
      type##_t res; \
      load_slow_path(addr, sizeof(type##_t), (uint8_t*)&res); \
      if (proc) READ_MEM(addr, size); \
      return from_le(res); \
    }
```
ä¸ºäº†ç²’åº¦ä¸åŒæ—¶ä¸å†™é‡å¤ä»£ç ï¼Œspikeçš„è®¾è®¡ä¸­å·§å¦™çš„åˆ©ç”¨äº†å®æ¥å®šä¹‰æ•´ä¸ªä»£ç ï¼Œåç»­åªè¦ä½¿ç”¨å®æ¥å®Œæˆå‡½æ•°å£°æ˜å³å¯ï¼›
å‡½æ•°é¦–å…ˆå¯¹åœ°å€çš„å¯¹é½è¿›è¡Œäº†æ£€æŸ¥ï¼Œè‹¥ä¸å¯¹é½ï¼Œåˆ™é€šè¿‡`misaligned_load`æ¥è¿›è¡ŒåŠ ï¼›ä¸å¯¹ç§°çš„æƒ…å†µä¸€èˆ¬è€Œè¨€ç¼–è¯‘å™¨æ˜¯ä¸ä¼šè®©å®ƒå‡ºç°çš„ï¼Œé‚£ä¹ˆå‡ºç°æ—¶å€™è¦ä¸å°±æ˜¯é»‘ç§‘æŠ€è¦ä¸å°±æ˜¯è¢«é»‘äº†å§ã€‚
æˆ‘ä»¬è¿˜æ˜¯å€’ç€çœ‹ï¼Œå‘ç°å‡½æ•°çš„æœ€ä¸‹é¢é€»è¾‘æ˜¯`load_slow_path()`ï¼Œåé¢æˆ‘ä»¬ä¼šåˆ†æï¼Œè°ƒç”¨è¯¥å‡½æ•°è¯´æ˜è¦å®Œæˆä¸€æ¬¡å®Œæ•´çš„TLB Walkæ¥å®Œæˆåœ°å€è½¬åŒ–ï¼Œä¹Ÿå°±æ„å‘³ç€æ­¤æ—¶TLBä¸­æ²¡æœ‰cacheè¿™ä¸ªè™šæ‹Ÿåœ°å€ï¼›ä»è€Œæˆ‘ä»¬å¯ä»¥åå‘æ¨ç†ï¼Œå‰é¢ä¸¤ç§æƒ…å†µå‡æ˜¯å¯ä»¥åœ¨TLBä¸­ç›´æ¥æ‰¾åˆ°è½¬åŒ–åœ°å€çš„ã€‚
é¦–å…ˆçœ‹çœ‹ç¬¬ä¸€ä¸ªåˆ†æ”¯
```c++
if (likely(tlb_load_tag[vpn % TLB_ENTRIES] == vpn)) {
    if (proc) READ_MEM(addr, size);
    return from_le(*(type##_t*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr));
```
æœç„¶æ˜¯åˆ°`tlb_load_tag`è¿™ä¸ªç»“æ„ä¸­å–å‡ºäº†äº†TLB Tagç„¶åä¸æ­¤æ¬¡çš„åœ°å€è¿›è¡Œæ¯”å¯¹ï¼›è¿™é‡Œæœ‰ä¸€å¥çªå…€çš„`if (proc) READ_MEM(addr, size);`ï¼Œå…¶å«ä¹‰æ˜¯å½“spikeå…è®¸**commit**åŠŸèƒ½æ—¶ä¼šå®Œæˆå†…å­˜è¯»å†™è½¨è¿¹çš„ä¸€ä¸ªè®°å½•å·¥ä½œã€‚è¿™ä¸ªç‚¹æ¯”è¾ƒç»†ï¼Œæˆ‘ä»¬å¯ä»¥ä¹‹åçš„æ–‡ç« ä¸­åˆ†æã€‚

æ—¢ç„¶TLBä¸­å·²ç»æœ‰äº†æ­¤è™šæ‹Ÿåœ°å€å¯¹åº”çš„ç‰©ç†åœ°å€ï¼Œæ¥ç€å°±å¯ä»¥è¯»å–æ•°æ®å¹¶è¿”å›äº†å§ã€‚ä»£ç ä¸­é€šè¿‡ä¸€å¥è¯å°±å®Œæˆäº†è¿™ä¸ªå·¥ä½œï¼Œ
```c++
return from_le(*(type##_t*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr));
```
è¿™é‡Œçš„`from_le()`æ˜¯ç”¨äºå¤„ç†å¤§å°ç«¯é—®é¢˜çš„ï¼Œæš‚æ—¶å¯ä»¥å…ˆæ”¾ä¸€è¾¹ã€‚è€Œæ•´ä¸ªå–å¯¹åº”ä½ç½®å€¼çš„å·¥ä½œï¼Œæ˜¯ç›´æ¥è®¡ç®—æ‹¿åˆ°TLBä¸­çš„åä¸º`host_offset`çš„å€¼åï¼Œä¸å¯¹åº”çš„è™šæ‹Ÿåœ°å€æ±‚å’Œï¼Œæ¥ç€ç›´æ¥ä½¿ç”¨æŒ‡é’ˆè§£å¼•ç”¨æ‹¿åˆ°å¯¹åº”çš„å€¼

> è¿™é‡Œè¦ææ¸…æ¥šçš„å‡ ä¸ªæ¦‚å¿µæ˜¯ï¼Œç”±äºæ˜¯è½¯ä»¶æ¨¡æ‹Ÿå†…å­˜çš„è½¬åŒ–ï¼Œä»è¢«æ¨¡æ‹Ÿçš„è§’åº¦çœ‹ï¼Œæ˜¯å­˜åœ¨æœ‰virtual addressä¸physcial addressä¸¤ç§å†…å­˜çš„å½¢å¼ã€‚å¯¹äºçœŸæ­£çš„ç‰©ç†æœºå™¨è€Œè¨€ï¼Œæ•°æ®æ˜¯å­˜å‚¨åœ¨physicall addressçš„è§†çª—ä¸‹çš„ã€‚è€Œä»ç”¨äºæ¨¡æ‹Ÿçš„è½¯ä»¶æ¥çœ‹ï¼Œå®é™…çš„æ•°æ®åœ¨hostæœºå™¨çš„å†…å­˜çš„è™šæ‹Ÿåœ°å€ä¸Šè¿›è¡Œå­˜å‚¨ï¼ˆæœ‰ç‚¹ç»• :D)ï¼Œæ‰€ä»¥ä¼šæœ‰ä¸€ä¸ªhost addressçš„æ¦‚å¿µã€‚è½¬åŒ–å¥½çš„physical addressè¦è¿›ä¸€æ­¥è½¬åŒ–æˆhost addressæ‰èƒ½æ‹¿åˆ°å¯¹åº”çš„æ•°æ®

æœ‰è¶£çš„æ˜¯ç¬¬äºŒä¸ªåˆ†æ”¯ï¼Œ
```c++
if (unlikely(tlb_load_tag[vpn % TLB_ENTRIES] == (vpn | TLB_CHECK_TRIGGERS))) { 
  type##_t data = from_le(*(type##_t*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr)); 
  if (!matched_trigger) { 
    matched_trigger = trigger_exception(OPERATION_LOAD, addr, data); 
    if (matched_trigger) 
      throw *matched_trigger; 
  } 
  if (proc) READ_MEM(addr, size); 
  return data; 
} 
```
ç”±äºæœ€å¼€å§‹æˆ‘æ²¡æœ‰å»è®¤çœŸç†è§£`likely`ä¸`unlikely`å¯¼è‡´äº†å¯¹äºç¨‹åºçš„ç†è§£æœ‰è¯¯ï¼Œå…¶æœ¬èº«ä¸ç¨‹åºçš„è¯­ä¹‰æ— å…³è€Œæ˜¯ç¼–è¯‘å™¨çš„ä¼˜åŒ–åŠŸèƒ½ï¼›å…¶ä¸­`likely`ä¸º`__builtin_expect((x), 1)`çš„å°è£…ï¼Œè¡¨ç¤ºæ­¤æ¡ä»¶å¤§æ¦‚ç‡ä¸ºçœŸï¼›è€Œ`unlikely`æ˜¯`__builtin_expect((x), 0)`çš„å°è£…ï¼Œè¡¨ç¤ºæ­¤æ¡ä»¶å¤§æ¦‚ç‡ä¸ºå‡ã€‚å€ŸåŠ©å¼€å‘è€…ä½¿ç”¨çš„è¿™äº›ä¿®é¥°ï¼Œç¼–è¯‘å™¨å¯ä»¥å°†æ¦‚ç‡è¾ƒå¤§çš„åˆ†æ”¯ä½œä¸ºåˆ¤æ–­åçš„ä»£ç ä»è€Œå‡å°‘*è·³è½¬æŒ‡ä»¤*å¸¦æ¥çš„å¼€é”€ã€‚

ä¹‹å‰ä¹Ÿè¯´é“äº†ï¼Œè¿™ä¸ªåˆ†æ”¯è¡¨è¾¾çš„åº”è¯¥ä¹Ÿæ˜¯å¯ä»¥ç›´æ¥ä»TLBä¸­æ‹¿åˆ°æ•°æ®ï¼Œé‚£ä¹ˆä¸ä¹‹å‰çš„åˆ†æ”¯æœ‰ä½•ä¸åŒå‘¢ï¼Œå…³é”®æ˜¯`TLB_CHECK_TRIGGERS`è¿™ä¸ªå€¼ï¼Œå¦‚æœåœ¨TLBä¸­çš„TAGæœ‰è¿™ä¸ªå€¼çš„markè¯ï¼Œæ ¹æ®æºä»£ç çš„æ³¨é‡Šï¼Œå…¶è¡¨è¾¾å¦‚ä¸‹å«ä¹‰
> If a TLB tag has TLB_CHECK_TRIGGERS set, then the MMU must check for a trigger match before completing an access.

è·Ÿè¸ªäº†ä»¥ä¸‹æºä»£ç å¹¶æŸ¥é˜…äº†ä¸€ä¸‹æ‰‹å†Œï¼Œå‘ç°æ­¤åŠŸèƒ½ä¸»è¦ä¸RISC-Vçš„Debug/Trace Registersç›¸å…³ï¼Œè¿™é‡Œä¹Ÿæ¶‰åŠåˆ°äº†è°ƒè¯•çš„éƒ¨åˆ†ï¼Œæˆ‘ä»¬æœªæ¥å†è¿›è¡Œåˆ†æã€‚

Perfectï¼ä¸¤ç§é€šè¿‡TLBè¿›è¡Œç›´æ¥è®¿é—®çš„æ–¹å¼å’±å·²ç»çœ‹å®Œäº†ï¼Œæ¥ç€çœ‹çœ‹`slow_path`çš„å…·ä½“å®ç°å¥½äº†ã€‚

```c++
void mmu_t::load_slow_path(reg_t addr, reg_t len, uint8_t* bytes)
{
  reg_t paddr = translate(addr, len, LOAD);

  if (auto host_addr = sim->addr_to_mem(paddr)) {
    memcpy(bytes, host_addr, len);
    if (tracer.interested_in_range(paddr, paddr + PGSIZE, LOAD))
      tracer.trace(paddr, len, LOAD);
    else
      refill_tlb(addr, paddr, host_addr, LOAD);
  } else if (!mmio_load(paddr, len, bytes)) {
    throw trap_load_access_fault(addr);
  }
.....
```

é¦–å½“å…¶å†²çš„è‡ªç„¶å°±æ˜¯`translate()`å‡½æ•°ï¼Œæˆ‘ä»¬çœ‹å®ƒçš„å®ç°
```c++
reg_t mmu_t::translate(reg_t addr, reg_t len, access_type type)
{
  if (!proc)
    return addr;
  reg_t mode = proc->state.prv;
  if (type != FETCH) {
    if (!proc->state.debug_mode && get_field(proc->state.mstatus, MSTATUS_MPRV))
      mode = get_field(proc->state.mstatus, MSTATUS_MPP);
  }
  reg_t paddr = walk(addr, type, mode) | (addr & (PGSIZE-1));
  if (!pmp_ok(paddr, len, type, mode))
    throw_access_exception(addr, type);
  return paddr;
}
```
ä»£ç é€»è¾‘ä¸Šï¼Œé¦–å…ˆå¦‚æœæ²¡æœ‰å®ä¾‹åŒ–å¤„ç†å™¨æŒ‡é’ˆçš„è¯ï¼Œå°±ç›´æ¥è¿”å›è¯¥åœ°å€ï¼ˆæ˜¯ä¸æ˜¯æ„å‘³ç€MMUæ²¡æœ‰æ‰“å¼€å‘¢ï¼‰å®Œæˆä¸€å®šçš„æ£€æŸ¥ä¹‹åï¼Œä¼šè°ƒç”¨å­å‡½æ•°`walk`è¿›è¡Œè½¬åŒ–ï¼Œè½¬æ¢ç»“æŸåï¼ŒåŒè¿›è¡Œpmp(physical-memory protection)æ£€æŸ¥ã€‚æœ€åæ‰è¿›è¡Œè¿”å›ã€‚`walk`å’Œ`pmp`éƒ½æ¯”è¾ƒç¡¬ä»¶ä½“ç³»ç›¸å…³äº†ï¼Œæœ€å¥½æ˜¯ç»“åˆç›¸å…³æ‰‹å†Œä¸€èµ·é£Ÿç”¨ï¼Œè¿™é‡Œé‡åœ¨åˆ†ææ¨¡æ‹Ÿå™¨å®ç°ï¼Œå°±å…ˆç•¥è¿‡äº†ã€‚

è‰è‰çš„çœ‹è¿‡`load_slow_path()`çš„`translate()`åï¼Œä¸‹ä¸€æ­¥å‡½æ•°è¿›å…¥ä¸€ä¸ªåˆ¤æ–­
`if (auto host_addr = sim->addr_to_mem(paddr)) {`ï¼Œå¹¶ä¸”å°±ä»£ç å»ç†è§£çš„è¯ï¼Œè¿™ä¸€æ¡ä»¶ä¸ºçœŸçš„è¯ï¼Œå³ä¼šåˆ°å¯¹åº”çš„ç‰©ç†ä½ç½®ä¸­å»å–å¾—ç›®æ ‡å€¼ï¼Œå¦‚æœè¿™ä¸€æ¡ä»¶ä¸ºå‡ï¼Œé‚£ä¹ˆä»£ç å°†é€šè¿‡`mmio_load(paddr, len, bytes)`æ¥å®Œæˆå€¼çš„è¯»å–ã€‚

ä»£ç é€»è¾‘æ˜¯æ¸…æ™°çš„ï¼Œä½†è¿™å‡ ä¸ªé™Œç”Ÿçš„å‡½æ•°ï¼Œæˆ‘ä»¬è¦æ”¾åˆ°åç»­çš„åˆ†æä¹‹ä¸­ã€‚ XD

#### STORE
STOREç›¸è¾ƒäºLOADå…¶å®å°±æ˜¯åç€æ¥çš„ä¸€ä¸ªè¿‡ç¨‹ï¼Œåœ¨ç†è§£äº†LOADçš„å®ç°åï¼ŒSTOREå…¶å®ä¹Ÿéå¸¸æ¸…æ™°ï¼›

è¯»è€…å¯ä»¥è‡ªè¡Œé˜…è¯»`riscv/mmu.h (store_func)`ä¸`riscv/mmu.cc (store_slow_path)`æ¥å®Œæˆæ•´ä¸ªstoreè¿‡ç¨‹çš„è®¨è®ºã€‚

#### FETCH
æŒ‡ä»¤fetchçš„æ•´ä¸ªä»£ç å®ç°ä¸load,storeå½“ç„¶è¿˜æ˜¯æœ‰æ˜¾è‘—çš„åŒºåˆ«â€”â€”é¦–å…ˆfetchç›¸å¯¹æ¥è¯´æ˜¯ä¸éœ€è¦ä¸ºä¸åŒç²’åº¦è¿›è¡Œä¸åŒå®ç°çš„ï¼ˆå“¦ï¼Œå½“ç„¶è¿™é‡Œå¿½ç•¥compressedæŒ‡ä»¤ï¼‰åœ¨å¤„ç†å™¨å±‚é¢çš„åˆ†æä¸Šï¼Œæˆ‘ä»¬ç®€åŒ–äº†å¯¹fetchçš„æè¿°ï¼Œè¿™é‡Œæˆ‘ä»¬å°†æ•´ä¸ªæµç¨‹ç»™åˆ†ææ¸…æ¥š

é¦–å…ˆçœ‹åˆ°`processor_t:step()`ä¸­ä½¿ç”¨`insn_fetch_t fetch = mmu->load_insn(pc);`æ¥å®Œæˆ`slow_path`ä¸‹çš„æŒ‡ä»¤åŠ è½½ï¼ˆå¦‚å•æ­¥è·Ÿè¸ªæ¨¡å¼ï¼‰ï¼Œé¦–å…ˆçœ‹çœ‹è¿™ä¸ªå‡½æ•°
```c++
// riscv/mmu.h
inline insn_fetch_t load_insn(reg_t addr)
{
  icache_entry_t entry;
  return refill_icache(addr, &entry)->data;
}
```
æ¥ç€å¾€ä¸‹çœ‹è¿™ä¸ªåä¸º`refill_icache()`çš„å‡½æ•°ï¼Œç”±äºä»£ç ç›¸æ¯”äºä¹‹å‰çš„é•¿ä¸€äº›ï¼Œæˆ‘ä»¬åˆ†æ®µæ¥åˆ†æ
```c++
// riscv/mmu.h
inline icache_entry_t* refill_icache(reg_t addr, icache_entry_t* entry)
{
  auto tlb_entry = translate_insn_addr(addr);
  insn_bits_t insn = from_le(*(uint16_t*)(tlb_entry.host_offset + addr));
  int length = insn_length(insn);
.....
```
é¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°æŒ‡ä»¤çš„åœ°å€`translate`æœ‰ç€è‡ªå·±çš„å‡½æ•°ï¼Œè€Œä¸æ˜¯ä¸`store`, `load`å¤ç”¨ï¼Œè¿™ä¹ˆåšå³æœ‰ç€æŠ½è±¡`ITLB`çš„ä½œç”¨ï¼Œè€Œä¸”æœ¬èº«ä¹Ÿé€šè¿‡å†…è”ä¼˜åŒ–æ¥è¿›è¡ŒåŠ é€Ÿï¼Œå…·ä½“çš„ä»£ç è¯»è€…å¯ä»¥è‡ªè¡Œé˜…è¯»ã€‚

```c++
  if (likely(length == 4)) {
    insn |= (insn_bits_t)from_le(*(const int16_t*)translate_insn_addr_to_host(addr + 2)) << 16;
  } else if (length == 2) {
    insn = (int16_t)insn;
  } else if (length == 6) {
    insn |= (insn_bits_t)from_le(*(const int16_t*)translate_insn_addr_to_host(addr + 4)) << 32;
    insn |= (insn_bits_t)from_le(*(const uint16_t*)translate_insn_addr_to_host(addr + 2)) << 16;
  } else {
    static_assert(sizeof(insn_bits_t) == 8, "insn_bits_t must be uint64_t");
    insn |= (insn_bits_t)from_le(*(const int16_t*)translate_insn_addr_to_host(addr + 6)) << 48;
    insn |= (insn_bits_t)from_le(*(const uint16_t*)translate_insn_addr_to_host(addr + 4)) << 32;
    insn |= (insn_bits_t)from_le(*(const uint16_t*)translate_insn_addr_to_host(addr + 2)) << 16;
  }
```
æ¥ç€å‘¢ï¼Œè¯¥å‡½æ•°åˆ©ç”¨å–å¾—çš„ä»£ç æ¥åˆ†æé•¿åº¦ï¼Œä»¥å†³å®šæ˜¯å¦è¦å¯¹æŒ‡ä»¤è¿›è¡Œè¿›ä¸€æ­¥çš„å¤„ç†ã€‚(ä¸€èˆ¬è€Œè¨€æŒ‡ä»¤éƒ½åº”è¯¥æ˜¯4bytesçš„ï¼Œè¿™é‡Œéœ€è¦å…³æ³¨åˆ°ä¸€äº›ç‰¹æ®Šçš„æŒ‡ä»¤é›†åˆ)

```c++
  insn_fetch_t fetch = {proc->decode_insn(insn), insn};
  entry->tag = addr;
  entry->next = &icache[icache_index(addr + length)];
  entry->data = fetch;

  reg_t paddr = tlb_entry.target_offset + addr;;
  if (tracer.interested_in_range(paddr, paddr + 1, FETCH)) {
    entry->tag = -1;
    tracer.trace(paddr, length, FETCH);
  }
  return entry;
}
```
éšåï¼Œè¿™é‡Œå°†å¤„ç†å¥½çš„æŒ‡ä»¤è¿›è¡Œè§£ç ï¼Œä¹Ÿå’Œæˆ‘ä»¬ä¹‹å‰å¯¹å¤„ç†å™¨çš„åˆ†æä¸€è‡´ã€‚éšåï¼ŒæŒ‡ä»¤çš„åœ°å€ä¸å®é™…å†…å®¹å°†å¡«å……åˆ°ITLBä¹‹ä¸­ï¼Œæ–¹ä¾¿ä¸‹ä¸€æ¬¡çš„è®¿é—®ã€‚

Wellï¼Œä¸ºäº†åŠ é€Ÿï¼Œ`processor_t:step()`å…¶å®ä¹Ÿå…·æœ‰ä¸€èˆ¬çš„å¿«é€Ÿçš„è®¿é—®æ–¹æ³•ï¼Œå³ä½¿ç”¨icacheï¼Œä»£ç å¦‚ä¸‹
```c++
// This figures out where to jump to in the switch statement
size_t idx = _mmu->icache_index(pc);

// This gets the cached decoded instruction from the MMU. If the MMU
// does not have the current pc cached, it will refill the MMU and
// return the correct entry. ic_entry->data.func is the C++ function
// corresponding to the instruction.
auto ic_entry = _mmu->access_icache(pc);
```
ä¸slowpathä¸åŒçš„æƒ…å†µçš„æ˜¯ï¼Œå…¶ä¸ä¸€å®šæ¯æ¬¡éƒ½æ‰§è¡Œ`refill_icache`æ“ä½œï¼Œä»¥æ­¤å®ç°äº†åŠ é€Ÿã€‚

è‡³æ­¤ï¼Œstore, loadä¸fetchå‡åˆ†æå®Œæ¯•ï¼›æ¯”è¾ƒæœ‰æ„æ€çš„ ITLB çš„å­˜åœ¨å› ä¸ºå¯ä»¥å‡å°‘æŒ‡ä»¤decodeçš„æ¬¡æ•°å·²å®ç°åŠ é€Ÿã€‚


### è®¾å¤‡
å””ï¼Œç»ˆäºåˆ°è®¾å¤‡äº†ã€‚å…¶å®å¤„ç†å™¨ã€ä»¥åŠå†…å­˜ç®¡ç†éƒ¨åˆ†çš„æ¨¡æ‹Ÿçš„ä»£ç è¿˜æ˜¯è¾ƒä¸ºç›´æ¥çš„ã€‚åœ¨æˆ‘å¯¹æ¨¡æ‹Ÿå™¨çš„ä¿®æ”¹è¿‡ç¨‹ä¸­ï¼Œä¸»è¦ä¹Ÿæ˜¯è®¾å¤‡å±‚é¢çš„ä¸€äº›ä¸œè¥¿ä¼šæœ‰å›°æ‰°â€”â€”æ¯•ç«Ÿè®¾å¤‡è¿™ç§ä¸œè¥¿æœ€éœ€è¦çš„å°±æ˜¯datasheetå‘€ï¼Œç›®å½•ä¸‹å•¥ä¹Ÿæ²¡æœ‰ï¼Œå¾ˆå¤šä¸œè¥¿çœŸçš„æŠ“çå“¦ã€‚

å¥½å•¦ï¼Œå¦‚æœæåˆ°è®¾å¤‡ï¼Œå“ªäº›ä¸œè¥¿æˆ‘ä»¬ä¼šå…³å¿ƒå‘¢ï¼Ÿ
1. æ•°æ®æ€»çº¿
2. åªè¯»å­˜å‚¨å™¨
3. ä¸»å­˜
4. ä¸­æ–­æ§åˆ¶å™¨

å®‰å•¦ï¼Œæ‰“èµ·ç²¾ç¥ç»§ç»­ç ”ç©¶ï¼Œæ•´ä¸ªæœ‰å…³äºè®¾å¤‡çš„å…³é”®ä»£ç èšé›†åœ¨`riscv/devices.h`å’Œ`riscv/devices.cc`ä¸­
å…¶ä¸­ï¼Œæœ€é¡¶å±‚çš„æŠ½è±¡ç±»å®šä¹‰å¦‚ä¸‹
```c++
// riscv/devices.h
class abstract_device_t {
public:
  virtual bool load(reg_t addr, size_t len, uint8_t* bytes) = 0;
  virtual bool store(reg_t addr, size_t len, const uint8_t* bytes) = 0;
  virtual ~abstract_device_t() {}
};
```
è¿™ä¸ªæŠ½è±¡è®¾å¤‡å®šä¹‰äº†çº¯è™šçš„`load`å’Œ`store`å‡½æ•°ï¼Œäº¤ç»™å…¶æ´¾ç”Ÿçš„è®¾å¤‡ç±»æ¥å®Œæˆã€‚

#### æ•°æ®æ€»çº¿ Databus
è‡ªç„¶ï¼Œæƒ³è¦ç†è§£æ¨¡æ‹Ÿå™¨å®ç°çš„databusçš„ä»£ç å†…æ¶µï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦äº†è§£æ•°æ®æ€»çº¿æœ¬èº«ï¼Œè€Œç»´åŸºç™¾ç§‘åœ¨æ™®åŠçŸ¥è¯†æ–¹é¢æ€»ä¸ä¼šè®©äººå¤±æœ›: [é“¾æ¥](https://zh.wikipedia.org/zh-cn/%E6%80%BB%E7%BA%BF)

> æ€»çº¿ï¼ˆBusï¼‰æ˜¯æŒ‡è®¡ç®—æœºç»„ä»¶é—´è§„èŒƒåŒ–çš„äº¤æ¢æ•°æ®ï¼ˆdataï¼‰çš„æ–¹å¼ï¼Œå³ä»¥ä¸€ç§é€šç”¨çš„æ–¹å¼ä¸ºå„ç»„ä»¶æä¾›æ•°æ®ä¼ é€å’Œæ§åˆ¶é€»è¾‘ã€‚ä»å¦ä¸€ä¸ªè§’åº¦æ¥çœ‹ï¼Œå¦‚æœè¯´ä¸»æ¿ï¼ˆMother Boardï¼‰æ˜¯ä¸€åº§åŸå¸‚ï¼Œé‚£ä¹ˆæ€»çº¿å°±åƒæ˜¯åŸå¸‚é‡Œçš„å…¬å…±æ±½è½¦ï¼ˆbusï¼‰ï¼Œèƒ½æŒ‰ç…§å›ºå®šè¡Œè½¦è·¯çº¿ï¼Œä¼ è¾“æ¥å›ä¸åœè¿ä½œçš„æ¯”ç‰¹ï¼ˆbitï¼‰

ç”±äºæ€»çº¿å­˜åœ¨çš„é‡è¦æ€§ï¼Œä¹Ÿåˆç†è§£é‡Šäº†å…¶åœ¨ä»£ç ç»“æ„ä¸Šç½®äºé å‰çš„åŸå› ï¼Œæˆ‘ä»¬å…ˆæŸ¥çœ‹ç±»çš„å£°æ˜ã€‚
```c++
class bus_t : public abstract_device_t {
public:
 	bool load(reg_t addr, size_t len, uint8_t* bytes);
  bool store(reg_t addr, size_t len, const uint8_t* bytes);
	void add_device(reg_t addr, abstract_device_t* dev);
	std::pair<reg_t, abstract_device_t*> find_device(reg_t addr);
private:
	std::map<reg_t, abstract_device_t*> devices;
};
```
å¯ä»¥çœ‹åˆ°ï¼Œ`bus_t`ç±»ç›¸è¾ƒäºçˆ¶ç±»æ·»åŠ äº†`add_device`æ–¹æ³•ï¼Œ`find_device`æ–¹æ³•ä¸åä¸º`devices`çš„ç§æœ‰mapæˆå‘˜ã€‚

æˆ‘ä»¬æ¥ç€ä¸€ä¸ªä¸€ä¸ªçš„è¿›è¡ŒæŸ¥çœ‹ã€‚
```c++
void bus_t::add_device(reg_t addr, abstract_device_t* dev)
{
  // Searching devices via lower_bound/upper_bound
  // implicitly relies on the underlying std::map 
  // container to sort the keys and provide ordered
  // iteration over this sort, which it does. (python's
  // SortedDict is a good analogy)
  devices[addr] = dev;
}
```
å½“ä¸€æ®µä»£ç çš„æ³¨é‡Šæ¯”ä»£ç å†…å®¹è¦å¤šçš„æ—¶å€™ï¼Œè¿™ä¸€éƒ¨åˆ†ä»£ç ä¸€å®šå¾ˆé‡è¦ ;D
å®é™…ä¸Šï¼Œä¸Šé¢çš„ä»£ç å°±æ˜¯ç®€å•åœ°å°†æŠ½è±¡è®¾å¤‡æŒ‡é’ˆåŠ å…¥æ•°æ®æ€»çº¿çš„ç§æœ‰æˆå‘˜`devices`ä¹‹ä¸­ã€‚
è€Œè¿™ä¸ªæ³¨é‡Šå‘¢ï¼Œå…¶å®æ˜¯è§£é‡Šåç»­find deviceæ‰€ä½¿ç”¨çš„æ–¹æ³•â€”â€”åˆ©ç”¨mapçš„lower_boundä¸upper_boundï¼Œè¿™å’Œpythonçš„SortedDictè¾ƒä¸ºç±»ä¼¼ã€‚

```c++
std::pair<reg_t, abstract_device_t*> bus_t::find_device(reg_t addr)
{
  // See comments in bus_t::load
  auto it = devices.upper_bound(addr);
  if (devices.empty() || it == devices.begin()) {
    return std::make_pair((reg_t)0, (abstract_device_t*)NULL);
  }
  it--;
  return std::make_pair(it->first, it->second);
}
```
`find_device`çš„é€»è¾‘è™½ç„¶ç®€å•ï¼Œä½†è®©æˆ‘ä»¬å…ˆçœ‹æ˜ç™½å®ƒè¦è¿”å›çš„ç›®æ ‡ç±»å‹ï¼Œå³`std::pair<reg_t, abstract_device_t*>`ï¼Œè¿™ä¸ªé”®å€¼å¯¹ç±»å‹å®é™…ä¸Šä¹Ÿåˆšåˆšæ˜¯databusçš„å†…éƒ¨æˆå‘˜å¯¹è±¡devices mapå­˜å‚¨çš„ç±»å‹ã€‚
å‡½æ•°é€šè¿‡`devices`çš„`upper_bound`ä¸æä¾›çš„åœ°å€æ¥è¿›è¡Œè®¾å¤‡å¯»æ‰¾ï¼Œæ³¨æ„ï¼Œå½“æ²¡æœ‰æ‰¾åˆ°æ­¤è®¾å¤‡æ—¶ï¼Œå®ƒå°†æ„é€ å¹¶è¿”å›ä¸€ä¸ªç©ºçš„pair.

æˆ‘ä»¬æ¥ç€åŒæ—¶åˆ†æ`load`å’Œ`store`çš„è¿‡ç¨‹
```c++
bool bus_t::load(reg_t addr, size_t len, uint8_t* bytes)
{
  // Find the device with the base address closest to but
  // less than addr (price-is-right search)
  auto it = devices.upper_bound(addr);
  if (devices.empty() || it == devices.begin()) {
    // Either the bus is empty, or there weren't 
    // any items with a base address <= addr
    return false;
  }
  // Found at least one item with base address <= addr
  // The iterator points to the device after this, so
  // go back by one item.
  it--;
  return it->second->load(addr - it->first, len, bytes);
}
bool bus_t::store(reg_t addr, size_t len, const uint8_t* bytes)
{
  // See comments in bus_t::load
  auto it = devices.upper_bound(addr);
  if (devices.empty() || it == devices.begin()) {
    return false;
  }
  it--;
  return it->second->store(addr - it->first, len, bytes);
}
```
æœ‰æ„æ€çš„æ˜¯ï¼Œ`load`å’Œ`store`ä¸­éƒ½ç”±ç±»ä¼¼`find`ä¸­ä½¿ç”¨çš„é€»è¾‘ï¼ŒåŒæ—¶ç”±äº`upper_bound`è¿”å›çš„æ˜¯ç¬¬ä¸€ä¸ªå¤§äºè¯¥é”®çš„å¯¹è±¡ï¼Œæ‰€ä»¥å¯¹è±¡éœ€è¦æ‰§è¡Œ`it--`åï¼Œæ‰èƒ½ç»§ç»­å¯¹åº”çš„è®¾å¤‡çš„`load`å’Œ`store`å‡½æ•°ã€‚

æ€»è€Œè¨€ä¹‹ï¼Œ`bus_t`ä¼šæ˜¯ä¸Šå±‚è®¿é—®ä¸‹å±‚è®¾å¤‡çš„å°è£…ï¼Œæˆ‘ä»¬ç»§ç»­åˆ†ææ›´å…·ä½“çš„è®¾å¤‡ç±»å‹

#### åªè¯»å­˜å‚¨å™¨ ROM

å®é™…ä¸Šï¼ŒROMçš„è®¾è®¡æœ¬èº«ä¼šå¾ˆç®€å•ï¼Œæˆ‘ä»¬å°†å£°æ˜ä¸å®šä¹‰ä¸€èµ·è¿›è¡Œåˆ†æ
```c++
// riscv/devices.h
class rom_device_t : public abstract_device_t {
public:
	  rom_device_t(std::vector<char> data);
  	bool load(reg_t addr, size_t len, uint8_t* bytes);
  	bool store(reg_t addr, size_t len, const uint8_t* bytes);
  	const std::vector<char>& contents() { return data; }
private:
  	std::vector<char> data;
};

// riscv/rom.cc
rom_device_t::rom_device_t(std::vector<char> data)
  : data(data)
{
}

bool rom_device_t::load(reg_t addr, size_t len, uint8_t* bytes)
{
  if (addr + len > data.size())
    return false;
  memcpy(bytes, &data[addr], len);
  return true;
}

bool rom_device_t::store(reg_t addr, size_t len, const uint8_t* bytes)
{
  return false;
}
```
å¯ä»¥çœ‹åˆ°ï¼Œ`rom_device_t`ç±»ä¸»è¦æ˜¯å¢è®¾äº†åä¸º`data`çš„vectorå¯¹è±¡ï¼Œå¹¶æä¾›åä¸º`contents()`çš„è®¿é—®æ–¹æ³•ã€‚
`load`å®ç°å°†åˆ©ç”¨è¾“å…¥çš„åœ°å€ï¼Œä»`data`ä¸­å–å‡ºæ•°æ®ï¼Œè€Œå› ä¸ºè®¾å¤‡æ˜¯åªè¯»çš„ï¼Œ`store`åªéœ€è¦åšé”™è¯¯è¿”å›å³å¯ã€‚

å¥½å§ï¼Œç®€å•è™½ç®€å•ï¼Œä½†æˆ‘ä»¬æ›´è¦çŸ¥é“å“ªå„¿ç”¨åˆ°äº†åªè¯»å­˜å‚¨çš„åŠŸèƒ½ï¼Œåœ¨ä¹‹å‰çš„[è®²è¿°spikeå¯åŠ¨Linuxçš„æ–‡ç« ](./010.md)ä¸­ï¼Œæˆ‘ä»¬åˆ†æäº†spikeåœ¨è·³å¾€bblç›¸å…³å‡½æ•°ä¹‹å‰æ‰€æ„é€ çš„ï¼Œæœ‰å…³è®¾å¤‡æ ‘çš„ä»£ç 
```c++
std::vector<char> rom((char*)reset_vec, (char*)reset_vec + sizeof(reset_vec));

dts = make_dts(INSNS_PER_RTC_TICK, CPU_HZ, initrd_start, initrd_end, procs, mems);
std::string dtb = dts_compile(dts);

rom.insert(rom.end(), dtb.begin(), dtb.end());
const int align = 0x1000;
rom.resize((rom.size() + align - 1) / align * align);

boot_rom.reset(new rom_device_t(rom));
bus.add_device(DEFAULT_RSTVEC, boot_rom.get());
```
ä»£ç ä¸­å…ˆä½¿ç”¨è·³å¾€`reset_vec`å‰çš„å‡†å¤‡ä»£ç æ„é€ ä¸€ä¸ªå‘é‡ï¼Œéšåå°†å‘é‡ä¸­åŠ å…¥`dts`ç›¸å…³çš„æ•°æ®ã€‚éšåï¼Œæˆ‘ä»¬çœ‹åˆ°åˆ©ç”¨`rom`å‘é‡å®ä¾‹åŒ–äº†`rom_device_t`ç±»å¹¶èµ‹å€¼ç»™boot_romæ™ºèƒ½æŒ‡é’ˆï¼Œå¹¶ä¸”å°†å…¶æ·»åŠ åˆ°äº†æ€»çº¿ä¹‹ä¸­ã€‚è¿™é‡Œ`add_device`ä¸­ä½¿ç”¨çš„åœ°å€`DEFAULT_RSTVEC`åœ¨`riscv/encoding.h`ä¸­å®šä¹‰ï¼Œå…¶å€¼ä¸º0x00001000ï¼Œå¯¹åº”ç€æ­¤`rom_device_t`åœ¨æ€»çº¿ä¸­çš„åŸºåœ°å€ã€‚

wellï¼Œè¿™å°±å¾ˆæ¸…æ¥šå“ˆ~

#### ä¸»å­˜ Memory
å†…å­˜æ˜¯è¦é©»ç•™è¿è¡Œæ—¶æ•°æ®çš„å…³é”®è®¾å¤‡ï¼Œæˆ‘ä»¬æ¥ç€å¯¹å…¶è¿›è¡Œåˆ†æã€‚é¦–å…ˆæˆ‘ä»¬æŸ¥çœ‹å…¶å£°æ˜
```c++
class mem_t : public abstract_device_t {
public:
  mem_t(size_t size) : len(size) {
    if (!size)
      throw std::runtime_error("zero bytes of target memory requested");
    data = (char*)calloc(1, size);
    if (!data)
      throw std::runtime_error("couldn't allocate " + std::to_string(size) + " bytes of target memory");
  }
  mem_t(const mem_t& that) = delete;
  ~mem_t() { free(data); }
  bool load(reg_t addr, size_t len, uint8_t* bytes) { return false; }
  bool store(reg_t addr, size_t len, const uint8_t* bytes) { return false; }
  char* contents() { return data; }
  size_t size() { return len; }

private:
  char* data;
  size_t len;
};
```
memory(mem_t)ä¸rom(rom_t)æœ‰å¾ˆå¤šç›¸ä¼¼ï¼Œå¦‚æ·»åŠ äº†dataå’Œcontentsï¼Œä¸è¿‡è¿˜é¢å¤–å¢åŠ äº†`size`æ¥ä½¿å¾—è®¿é—®æ›´åŠ æ–¹ä¾¿ã€‚
> è¿™é‡Œçš„ `=delete` å®Œæˆçš„æ˜¯[é»˜è®¤æ„é€ å‡½æ•°](https://zh.cppreference.com/w/cpp/language/default_constructor)åŠŸèƒ½çš„æ˜¾ç¤ºç¦ç”¨å‡½æ•°ï¼Œè§[ä¾‹å­](https://www.geeksforgeeks.org/explicitly-defaulted-deleted-functions-c-11/)

å†…å­˜çš„å®ç°è¿™ä¹ˆç®€å•è‡ªç„¶ä¹Ÿå¾ˆåˆç†ï¼Œæ¯•ç«Ÿå°±åªéœ€è¦è¯»å†™çš„åŠŸèƒ½å°±å¤Ÿäº†ã€‚æˆ‘ä»¬æ¥çœ‹çœ‹spikeæ˜¯åœ¨å“ªå„¿å®Œæˆå†…å­˜çš„å®ä¾‹åŒ–çš„ã€‚

å®åŠ›åŒ–æµç¨‹ä¸º`spike_main/spike.cc main()`å†…é€šè¿‡ç”¨æˆ·è®¾ç½®è°ƒç”¨`spike_main/make_mems()`ï¼Œé»˜è®¤çš„æƒ…å†µä¸‹å°†è®¾ç½®ç‰©ç†å†…å­˜ä¸º2048MBä¹Ÿå°±æ˜¯2GBç©ºé—´ã€‚
å®ä¾‹åŒ–çš„`mems`å°†ç»§ç»­åœ¨`sim`å¯¹è±¡çš„å®ä¾‹åŒ–è¿‡ç¨‹ä¸­åŠ å…¥`bus_t`ä¹‹ä¸­ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œå³ä»…æœ‰ä¸€å—è¿ç»­çš„memoryæ—¶ï¼Œå†…å­˜åœ¨æ€»çº¿ä¸­çš„èµ·å§‹*ç‰©ç†*åœ°å€ä¸º0x80000000ï¼Œå®šä¹‰åœ¨`riscv/encoding/h`ä¸­

#### Clintä¸­æ–­å™¨
åŒç†è§£databusä¸€æ ·ï¼Œæˆ‘ä»¬é¦–å…ˆè¦ç†è§£Clintä¸­æ–­çš„å†…æ¶µæ‰èƒ½æ¢è®¨å…¶ä»£ç çš„å®ç°ï¼Œå‚è€ƒriscvçš„[æ‰‹å†Œ](https://github.com/riscv/riscv-fast-interrupt/blob/master/clic.adoc)ï¼Œæœ‰è¿™æ ·çš„æ¦‚æ‹¬
> The Core-Local Interrupt Controller (CLIC) is designed to provide low-latency, vectored, pre-emptive interrupts for RISC-V systems.

è™½ç„¶æ‰‹å†Œé‡Œé¢å˜Ÿå˜Ÿå˜Ÿè¯´äº†ä¸€å¤§å †ï¼Œä¸è¿‡ **Talk is cheap, show me the code**ï¼Œåˆ†æä»£ç æ¥çœ‹è¿™é‡Œå®ç°çš„å†…åŠŸå¹¶ä¸å¤šï¼Œæˆ‘ä»¬çœ‹ä¸‹å£°æ˜
```c++
// riscv/devices.h
class clint_t : public abstract_device_t {
public:
	clint_t(std::vector<processor_t*>&, uint64_t freq_hz, bool real_time);
	bool load(reg_t addr, size_t len, uint8_t* bytes);
  bool store(reg_t addr, size_t len, const uint8_t* bytes);
  size_t size() { return CLINT_SIZE; }
  void increment(reg_t inc);
private:
	typedef uint64_t mtime_t;
	typedef uint64_t mtimecmp_t;
	typedef uint32_t msip_t;
	std::vector<processor_t*>& procs;
	uint64_t freq_hz;
	bool real_time;
	uint64_t real_time_ref_secs;
	uint64_t real_time_ref_usecs;
	mtime_t mtime;
	std::vector<mtimecmp_t> mtimecmp;
};
```
ç›¸æ¯”èµ·å‰é¢å‡ ä¸ªè®¾å¤‡è€Œè¨€ï¼Œæ·»åŠ äº†ä¸å°‘çš„æˆå‘˜ï¼Œè‡ªç„¶ï¼Œæ„å‘³ç€å…¶å¤æ‚æ€§è¾ƒé«˜ã€‚çœ‹å®Œå£°æ˜çœ‹å®šä¹‰ï¼Œå…ˆçœ‹æ„é€ å‡½æ•°å¦‚ä½•

```c++
// riscv/clint.cc
clint_t::clint_t(std::vector<processor_t*>& procs, uint64_t freq_hz, bool real_time)
  : procs(procs), freq_hz(freq_hz), real_time(real_time), mtime(0), mtimecmp(procs.size())
{
  struct timeval base;

  gettimeofday(&base, NULL);

  real_time_ref_secs = base.tv_sec;
  real_time_ref_usecs = base.tv_usec;
}
```
è¿™é‡Œçš„`timeval`æ˜¯linuxä¸‹çš„ç»“æ„ä½“è¡¨è¿°ï¼Œè¿™å„¿åˆå§‹åŒ–çš„ä½œç”¨å¤§æ¦‚å°±æ˜¯å¯¹ä¸€äº›å˜é‡è¿›è¡Œèµ‹å€¼è€Œå·²ã€‚

```c++
void clint_t::increment(reg_t inc)
{
  if (real_time) {
   struct timeval now;
   uint64_t diff_usecs;

   gettimeofday(&now, NULL);
   diff_usecs = ((now.tv_sec - real_time_ref_secs) * 1000000) + (now.tv_usec - real_time_ref_usecs);
   mtime = diff_usecs * freq_hz / 1000000;
  } else {
    mtime += inc;
  }
  for (size_t i = 0; i < procs.size(); i++) {
    procs[i]->state.mip &= ~MIP_MTIP;
    if (mtime >= mtimecmp[i])
      procs[i]->state.mip |= MIP_MTIP;
  }
}
```
`increment`å¬èµ·æ¥çœŸçš„å¾ˆæ—¶é’Ÿå“ˆï¼Œåœ¨æ‰§è¡Œé€»è¾‘`step()`ä¸­ä¹Ÿè¡¨æ˜æ¯æ¬¡æŒ‡ä»¤æ‰§è¡Œï¼Œæ—¶é’Ÿéƒ½éšä¹‹å˜åŒ–
```c++
clint->increment(INTERLEAVE / INSNS_PER_RTC_TICK);
```
ä»£ç çš„é€»è¾‘(å½“ç„¶ä¸æ˜¯real_timeæ¥æ¨¡æ‹Ÿæ—¶)ï¼Œå°±æ˜¯ç®€å•çš„å¢åŠ æˆå‘˜`mtime`çš„å€¼ï¼Œéšåç»™å„ä¸ªå¤„ç†å™¨çš„æ—¶é’Ÿä¸­æ–­çŠ¶æ€`state.mip`è¿›è¡Œå¤„ç†ã€‚å¦‚å½“å‰æ—¶é’Ÿè¶…è¿‡å¯¹å‘€processorçš„mtimecmpå€¼æ—¶ï¼Œç»™`state.mip`çš„MTIP bitç½®ä½ã€‚

> The MTIP, STIP, UTIP bits correspond to timer interrupt-pending bits for machine, supervisor, and user timer interrupts,

å…·ä½“æœ‰å“ªäº›ä¸­æ–­ç›¸å…³çš„å¯„å­˜å™¨è¢«æ¨¡æ‹Ÿäº†(å³ä½¿å€¼éƒ½æ˜¯ç”±processor stateç»´æŠ¤çš„)ï¼Œæˆ‘ä»¬å¯ä»¥é˜…è¯»ä»£ç ä¸­çš„å£°æ˜ä¸­çš„è¿™ä¸ªéƒ¨åˆ†
```c++
// riscv/devices.hh
typedef uint64_t mtime_t;
typedef uint64_t mtimecmp_t;
typedef uint32_t msip_t;
```
å†æŸ¥çœ‹ä¸€ä¸‹`riscv/clint.cc`ä¸­å…·ä½“çš„`load`å’Œ`store`å®ç°ï¼Œå°±å¯ä»¥æ¸…æ¥šclintä¸­æ–­æ§åˆ¶å™¨å®ç°äº†*mtime*, *mtimecmp* ä¸ *msip* è¿™å‡ ä¸ªå¯„å­˜å™¨ï¼Œä¾é å…¶å®Œæˆæ—¶é’Ÿä¸­æ–­çš„æ¨¡æ‹Ÿã€‚å…·ä½“çš„`load`å’Œ`store`å®ç°å°±æ˜¯æ ¹æ®åœ°å€æ¥è¯»å†™ï¼Œè¿™é‡Œå°±ç•¥è¿‡åˆ†æäº†ã€‚

æˆ‘ä»¬æ‰¾æ‰¾çœ‹`clint`çš„å®ä¾‹åŒ–ï¼Œå…¶åŒ`mems`ä¸€æ ·æ˜¯åœ¨`sim_t`å¯¹è±¡å®ä¾‹åŒ–æ—¶æ¥å®Œæˆçš„ï¼Œä»£ç å¦‚ä¸‹
```c++
clint.reset(new clint_t(procs, CPU_HZ / INSNS_PER_RTC_TICK, real_time_clint));
bus.add_device(CLINT_BASE, clint.get());
```
å…·ä½“çš„CPUçš„é¢‘ç‡ä»€ä¹ˆçš„æˆ‘ä»¬å°±ä¸å…³å¿ƒäº†ï¼Œå…¶ä¸­`CLINT_BASE`å€¼ä¸º0x02000000ï¼Œå®šä¹‰åœ¨`riscv/encoding.h`ä¸­

### å…¶ä»–è®¾å¤‡
å¦‚æœåªä» `riscv/devices.h` ä¸­åˆ†æï¼Œä¸Šä¸€å­—èŠ‚å…¶å®å·²ç»å°†æ¶‰åŠçš„è®¾å¤‡å®Œå…¨ä»‹ç»äº†ã€‚
å½“ç„¶ï¼Œç–‘æƒ‘ä»å­˜åœ¨ï¼Ÿä¸ºå•¥æ²¡æœ‰çœ‹åˆ°I/Oè®¾å¤‡å‘¢ï¼Ÿæ¯•ç«Ÿæ²¡æœ‰I/Oçš„è®¡ç®—æœºå¯ä¸å®Œæ•´å‘€ï¼Ÿ

å½“ç„¶ï¼Œä½†ä»æ¨¡æ‹Ÿå™¨è§’åº¦æ¥çœ‹ï¼Œåƒ`console`, `block devices`ä»¥åŠ`network devices`è¿™æ ·çš„ï¼Œä»–ä»¬ä¸`memory`, `rom`ä¸åŒï¼Œå®ƒä»¬è¦ä¾é hostæœºå™¨æ¥å£æ¥å®Œæˆã€‚æ¯”å¦‚è¾“å…¥è¾“å‡ºå­—ç¬¦ï¼Œæ˜¯è¦åæ˜ åˆ°hostæœºå™¨çš„è¡Œä¸ºä¸Šæ¥çš„ã€‚

ä¸ºäº†å¤„ç†è¿™ç§æƒ…å†µï¼Œrisc-vçš„[software stack](https://riscv.org/wp-content/uploads/2015/01/riscv-software-stack-bootcamp-jan2015.pdf)å®ç°äº†fesvræœºåˆ¶ï¼Œå³frontend serverï¼Œå‰ç«¯æœåŠ¡å™¨ã€‚

> è¿™æ ·çš„å‘½åï¼Œå¯èƒ½æ˜¯æŠ½è±¡çš„æŠŠæ¥å£ä½œä¸ºæœåŠ¡æ¥æä¾›æŠŠï¼›

riscv-fesvræä¾›å„ç±»åŠŸèƒ½ï¼Œæ¦‚æ‹¬å¦‚ä¸‹
- Facilitates	communication	between	a	host machine and a RISC-V	target
- ELF loading, peripheral device emulation over HTIF
- HTIF (Host Target InterFace): Communication bus for test hardware
- Some other FPGA support

å¥½çš„ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†ä¸€ä¸ªæœ‰è¶£çš„è€Œä¸”ç›¸å…³çš„æ¦‚å¿µï¼ŒHTIF(Host Target InterFace)ï¼Œå®ƒå®é™…ä¸Šå°±è´Ÿè´£ä¸»æœºç¨‹åºä¸è¢«æ¨¡æ‹Ÿå¯¹è±¡çš„é€šä¿¡ã€‚å®˜æ–¹è¯´æ˜ä¸­ï¼Œå…¶ç”¨äºå®ç°
- Non-blocking FIFO Interface, communicates non-zero values	
- Existing driver/device implementations: (console, block-devices, networking)

So far so good! æˆ‘æ²¡æ‰¾åˆ°äº†æƒ³è¦çš„ä¸œè¥¿ï¼Œæ¥ç€å°±å¾—çœ‹å¦‚ä½•å®ç°å•¦ã€‚

é¦–å…ˆæˆ‘ä»¬çœ‹ä¸€ä¸‹bblä¸­çš„å®ç°ï¼ˆæ³¨æ„è¿™é‡Œçš„ä»£ç æ ¹ç›®å½•è¦æ”¹å˜å’¯ :Pï¼‰
```c++
// riscv-pk/machine/htif.h
#if __riscv_xlen == 64
# define TOHOST_CMD(dev, cmd, payload) \
  (((uint64_t)(dev) << 56) | ((uint64_t)(cmd) << 48) | (uint64_t)(payload))
#else
# define TOHOST_CMD(dev, cmd, payload) ({ \
  if ((dev) || (cmd)) __builtin_trap(); \
  (payload); })
#endif
#define FROMHOST_DEV(fromhost_value) ((uint64_t)(fromhost_value) >> 56)
#define FROMHOST_CMD(fromhost_value) ((uint64_t)(fromhost_value) << 8 >> 56)
#define FROMHOST_DATA(fromhost_value) ((uint64_t)(fromhost_value) << 16 >> 16)
extern uintptr_t htif;
void query_htif(uintptr_t dtb);
void htif_console_putchar(uint8_t);
int htif_console_getchar();
void htif_poweroff() __attribute__((noreturn));
void htif_syscall(uintptr_t);
```
å¯ä»¥çœ‹åˆ°ï¼Œè¿™éƒ¨åˆ†ä»£ç é¦–å…ˆå°è£…äº†éšåè¦ä½¿ç”¨çš„`TOHOST_CMD`ï¼Œ`FROMHOST_DEV`ï¼Œ`FROMHOST_CMD`ï¼Œ`FROMHOST_DATA`è¿™äº›å®ï¼Œæˆ‘ä»¬ç­‰ä¼šæ¥åˆ†æå®ƒä»¬ã€‚æ­¤å¤–ï¼Œå®šä¹‰äº†ä¸€ä¸ª`uintptr_t`ç±»å‹çš„`htif`çš„å˜é‡ï¼Œä»¥åŠå…¶ä»–çš„æ–¹æ³•ã€‚ç”±äºæ•´ä¸ªå†…å®¹éƒ½å¾ˆé‡è¦ï¼Œæˆ‘ä»¬æ¥ç€ä»”ç»†çš„è·Ÿè¸ªåˆ†æ

```c++
// riscv-pk/machine/htif.cc
void htif_console_putchar(uint8_t ch)
{
#if __riscv_xlen == 32
  // HTIF devices are not supported on RV32, so proxy a write system call
  volatile uint64_t magic_mem[8];
  magic_mem[0] = SYS_write;
  magic_mem[1] = 1;
  magic_mem[2] = (uintptr_t)&ch;
  magic_mem[3] = 1;
  do_tohost_fromhost(0, 0, (uintptr_t)magic_mem);
#else
  spinlock_lock(&htif_lock);
    __set_tohost(1, 1, ch);
  spinlock_unlock(&htif_lock);
#endif
}
```
ä»£ç ä¸­å·²ç»æ ‡æ³¨ï¼Œå¦‚æœæ˜¯32ä½çš„æƒ…å†µï¼ŒHTIFè®¾å¤‡ä¸è¢«æ”¯æŒåªèƒ½é€šè¿‡proxy write sysacllå®Œæˆï¼›è€Œ64ä½çš„æƒ…å†µåˆ™ä¼šåœ¨é”çš„ä¿æŠ¤ä¸‹è°ƒç”¨`__set_tohost()`ï¼Œæœ‰è¶£ï¼Œæˆ‘ä»¬çœ‹çœ‹å®ƒçš„å®ç°

```c++
static void __set_tohost(uintptr_t dev, uintptr_t cmd, uintptr_t data)
{
  while (tohost)
    __check_fromhost();
  tohost = TOHOST_CMD(dev, cmd, data);
}
```
å‘ç°å…¶åªæœ‰åœ¨å˜é‡`tohost`ä¸ºé›¶æ—¶æ‰èƒ½è„±ç¦»æ­»å¾ªç¯ï¼Œéšåä¸º`tohost`èµ‹äºˆä¸€ä¸ªCMDå€¼ï¼›

putchar()å°±è¿™æ ·äº†ï¼Œé‚£ä¹ˆgetchar()å‘¢ï¼Ÿ
```c++
int htif_console_getchar()
{
#if __riscv_xlen == 32
  // HTIF devices are not supported on RV32
  return -1;
#endif
  spinlock_lock(&htif_lock);
    __check_fromhost();
    int ch = htif_console_buf;
    if (ch >= 0) {
      htif_console_buf = -1;
      __set_tohost(1, 0, 0);
    }
  spinlock_unlock(&htif_lock);
  return ch - 1;
}
```
å¯ä»¥çœ‹åˆ°32ä½æƒ…å†µä¸‹å°†ç›´æ¥è¿”å›ï¼Œè€Œé»˜è®¤çš„64ä½æ¶æ„ä¸‹ï¼Œé¦–å…ˆä¼šæ£€æŸ¥ä¸€ä¸‹`fromhost`ï¼Œç„¶åå°†ä»`htif_console_buf`ä¸­å–å¾—ä¸€ä¸ªå­—ç¬¦ï¼Œå½“å­—ç¬¦éé›¶æ—¶ï¼Œå°†æ­¤bufç½®ç©ºç„¶åå³åˆè°ƒç”¨ä¸€æ¬¡`__set_tohost`

è¿™é‡Œæ¶‰åŠåˆ°çš„å˜é‡ï¼Œå…³é”®çš„æ˜¯å¦‚ä¸‹ä¸¤ä½
```c++
volatile uint64_t tohost __attribute__((section(".htif")));
volatile uint64_t fromhost __attribute__((section(".htif")));
```
åœ¨å˜é‡å®šä¹‰çš„æ—¶å€™ï¼Œæˆ‘ä»¬èƒ½å¤Ÿçœ‹åˆ°`__attribute__((section(".htif")))`ï¼Œè¿™äº›å˜é‡åœ¨ç¨‹åºä¸­ä¼šæ”¾ç½®åˆ°ä¸€ä¸ªåä¸º*.htif*çš„æ®µä¸­ã€‚è¿™ä¸ªæ®µæœ‰å•¥ç¥å¥‡çš„ï¼Ÿæˆ‘ä»¬æŸ¥çœ‹bblæ„å»ºæ—¶å€™çš„é“¾æ¥è„šæœ¬
```c++
// riscv-pk/bbl.lds
/*--------------------------------------------------------------------*/
/* HTIF, isolated onto separate page                                  */
/*--------------------------------------------------------------------*/
.htif :
{
  PROVIDE( __htif_base = . );
  *(.htif)
}
. = ALIGN(0x1000);
```
å¯ä»¥å‘ç°ï¼Œè¿™æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æ®µğŸ¤”ï¸æ ¹æ®æ‰‹å†Œä¸Šç»™å‡ºçš„æè¿°
> In RV64 implmentations, two 64-bit communication registers in CSR space: (1) fromhost: Host writes, RISC-V target reads. (2) RISC-V target writes, Host reads.

æˆ‘ä»¬å†çœ‹ä¸€ä¸‹è¿™ä¸ªå€¼çš„ç¼–ç ä¸è§£ç 
```c++
#define TOHOST_CMD(dev, cmd, payload) 
  (((uint64_t)(dev) << 56) | ((uint64_t)(cmd) << 48) | (uint64_t)(payload))
```
å¯ä»¥çœ‹åˆ°`tohost`ç¼–ç æƒ…å†µ
```c
0x H H H H H H H H H H H H H H H H
   | | | | |                     |  
   \ / \ / \                     /
   dev cmd         payload 
```
ç”±äºputcharå®é™…åªéœ€è¦8bitçš„payloadï¼Œè¿™é‡Œ48bitç®—æ˜¯å®Œå…¨å¤Ÿäº†ã€‚

OKAYï¼Œtargetç«¯çš„æ¨¡æ‹ŸåŸºæœ¬å¾ˆæ¸…æ¥šå•¦ï¼Œæˆ‘ä»¬å¯ä»¥éšåçœ‹çœ‹hostç«¯å¦‚ä½•æ“ä½œã€‚åœ¨å…ˆå‰çš„è®¨è®ºçš„Linuxå¯åŠ¨ä¸­æè¿°çš„spikeéƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬çŸ¥é“ç¨‹åºè¿è¡Œåœ¨`htif::run()`åœ¨è°ƒç”¨`start()`åï¼Œä¸»çº¿ç¨‹ä¼šæŒç»­ç•™åœ¨ä¸€ä¸ªæ­»å¾ªç¯ä¸­ï¼Œå¦‚ä¸‹
```c++
while (!signal_exit && exitcode == 0)
{
  if (auto tohost = from_le(mem.read_uint64(tohost_addr))) {
    mem.write_uint64(tohost_addr, 0);
    command_t cmd(mem, tohost, fromhost_callback);
    device_list.handle_command(cmd);
  } else {
    idle();
  }
  device_list.tick();
  if (!fromhost_queue.empty() && mem.read_uint64(fromhost_addr) == 0) {
    mem.write_uint64(fromhost_addr, to_le(fromhost_queue.front()));
    fromhost_queue.pop();
  }
}
```

wellæˆ‘ä»¬å¯ä»¥å¤§æ¦‚çœ‹åˆ°è¿™ä¸ªä¸»å¾ªç¯çš„é€»è¾‘ï¼Œå³å…ˆä»`tohost_add`ä¸­å–å¾—targetæ‰€è®¾ç½®çš„`tohost`å˜é‡çš„å€¼ï¼Œå°†è¿™ä¸ªå€¼ç»„æˆ`command_t`ç»“æ„ä½“ï¼Œç„¶åäº¤ç”±`device_list`å»å¤„ç†ï¼›å¤„ç†å®Œä¹‹åä¼šè°ƒç”¨`device_list`çš„`tick`æ–¹æ³•ï¼›éšåï¼Œä¼šæ£€æŸ¥`fromhost_queue`é˜Ÿåˆ—å¹¶å†³å®šæ˜¯å¦è¦å‘`fromhost_addr`ä¸­å†™å…¥ç›®æ ‡çš„å€¼ã€‚

*device_list*ï¼Ÿè¿™é‡Œçš„è®¾å¤‡æŒ‡å“ªäº›å‘¢ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹åˆå§‹åŒ–çš„æ—¶å€™ï¼Œå³`sim_t`å¯¹è±¡åˆå§‹åŒ–æ—¶å®Œæˆçˆ¶ç±»æ„é€ å‡½æ•°æ—¶
```c++
// riscv-isa-sim/fesvr/htif.cc
htif_t::htif_t(int argc, char** argv) : htif_t()
{
  parse_arguments(argc, argv);
  register_devices();   // <- here
}
....
void htif_t::register_devices()
{
  device_list.register_device(&syscall_proxy);
  device_list.register_device(&bcd);
  for (auto d : dynamic_devices)
    device_list.register_device(d);
}
```
ä¸‹é¢çš„`dynamic_devices`æ˜¯ç”¨æˆ·å¯ä»¥é¢å¤–æ·»åŠ çš„æ‹“å±•çš„è®¾å¤‡ï¼ˆæœªæ¥spikeåº”è¯¥ä¼šæ”¯æŒç½‘ç»œè®¾å¤‡å’¯ï¼‰æˆ‘ä»¬å¯ä»¥å…ˆçœ‹çœ‹å‰ä¸¤è€…`syscall_proxy`å’Œ`bcd`ï¼›å‰æ–‡æœ‰æåˆ°ï¼Œ`syscall_proxy`ä¸»è¦å‘¢æ˜¯ä¸ºäº†æ”¯æŒ`pk`è€Œè®¾è®¡çš„ï¼Œç”±äºæˆ‘ä»¬é‡ç‚¹è€ƒè™‘`bbl linux`ï¼Œå…¶è‡ªèº«æœ‰ç³»ç»Ÿè°ƒç”¨å®ç°ï¼Œå¤šæ•°æƒ…å†µä¸‹æ— éœ€ä»£ç†ã€‚æ‰€ä»¥å°±å•çº¯çœ‹çœ‹`bcd`å¥½äº†ã€‚
```c++
// riscv-isa-sim/fesvr/device.h
class bcd_t : public device_t
{
public:
  bcd_t();
  const char* identity() { return "bcd"; }
  void tick();
private:
  void handle_read(command_t cmd);
  void handle_write(command_t cmd);
  std::queue<command_t> pending_reads;
};
```
æˆ‘ä»¬æ‰¾åˆ°ç±»çš„å£°æ˜ï¼Œå…¶æ´¾ç”Ÿè‡ª`device_t`ç±»ï¼Œè¯¥ç±»å†…éƒ¨æä¾›äº†å¦‚`void handle_command(command_t cmd);`ç­‰çš„æ¥å£ï¼›æˆ‘ä»¬æ¥çœ‹çœ‹å…¶æ–¹æ³•çš„å…·ä½“å®ç°ã€‚
```c++
bcd_t::bcd_t()
{
  register_command(0, std::bind(&bcd_t::handle_read, this, _1), "read");
  register_command(1, std::bind(&bcd_t::handle_write, this, _1), "write");
}
void bcd_t::handle_read(command_t cmd)
{
  pending_reads.push(cmd);
}
void bcd_t::handle_write(command_t cmd)
{
  canonical_terminal_t::write(cmd.payload());
}
void bcd_t::tick()
{
  int ch;
  if (!pending_reads.empty() && (ch = canonical_terminal_t::read()) != -1)
  {
    pending_reads.front().respond(0x100 | ch);
    pending_reads.pop();
  }
}
```
å“ˆå“ˆï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ•´ä¸ªé€»è¾‘æ˜¯éå¸¸éå¸¸æ¸…æ™°çš„ã€‚åœ¨æ„é€ å‡½æ•°ä¸­ï¼Œå…¶é€šè¿‡`register_command`å‘`device_list`ä¸­æ³¨å†Œäº†è‡ªå·±çš„è¯»å†™å®ç°ã€‚å…¶`handle_read`å®ç°å®é™…ä¸Šå°±æ˜¯æƒ³ç­‰å¾…é˜Ÿåˆ—`pending_reads`ä¸­åŠ å…¥å‘½ä»¤ï¼Œè¿™ä¸ªå‘½ä»¤å°†åœ¨`tick()`ä¸­å®Œæˆæ‰§è¡Œï¼Œå…¶å®é™…ä¸Šæ˜¯è°ƒç”¨äº†`canonical_terminal_t`çš„`read()`æ–¹æ³•ï¼Œæˆ‘ä»¬è¿›ä¸€æ­¥çœ‹å…¶å®ç°
```c++
int canonical_terminal_t::read()
{
  struct pollfd pfd;
  pfd.fd = 0;
  pfd.events = POLLIN;
  int ret = poll(&pfd, 1, 0);
  if (ret <= 0 || !(pfd.revents & POLLIN))
    return -1;
  unsigned char ch;
  ret = ::read(0, &ch, 1);
  return ret <= 0 ? -1 : ch;
}
```
wellï¼Œè¿™é‡Œå·²ç»çœ‹åˆ°äº†hostç«¯çš„ç³»ç»Ÿè°ƒç”¨readäº†ï¼ŒåŒæ—¶`canonical_terminal_t`ç”¨`pollfs`ç»“æ„æ¥ç®¡ç†å¥æŸ„ï¼Œä»¥ä¿è¯æ‰§è¡Œçš„å‡†ç¡®æ€§ã€‚
çŸ¥é“äº†`read`ï¼Œ`write`è‡ªç„¶ä¹Ÿä¸è¿œå•¦ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°`bcd_t`çš„writeå®é™…ä¸Šæ˜¯æ‰§è¡Œäº†`canonical_terminal_t::write()`ï¼Œè€Œè¯¥å®ç°å°±æ˜¯å€ŸåŠ©äº†hostç«¯çš„writeæ–¹æ³•ï¼Œå¦‚ä¸‹ã€‚
```c++
void canonical_terminal_t::write(char ch)
{
  if (::write(1, &ch, 1) != 1)
    abort();
}
```
è¿™æ ·ï¼Œæˆ‘ä»¬ç®—æ˜¯æ¸…æ¥šäº†`console`çš„è®¾å¤‡å®ç°å•¦ã€‚é˜…è¯»`riscv-isa-sim/fesver/device.h`å…¶å®è¿˜èƒ½æ‰¾åˆ°ä¸€ä¸ª`disk_t`ç±»ï¼Œä¸è¿‡è¿‘æœŸçš„diskåŠŸèƒ½å·²ç»ä¸è¢«æ”¯æŒï¼Œæˆ‘ä»¬æˆ–è®¸åœ¨å…¶ä»–æ–‡ç« ä¸­æ¥æ¢è®¨æ¢è®¨ã€‚

æ”¯æŒï¼Œåˆ†è€Œæ²»ä¹‹çš„æ•´ä¸ªç¡¬ä»¶ä½“ç³»ç§¯æœ¨å·²ç»éƒ½è®¨è®ºè¿‡äº†ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è¯•ç€ä»high levelçš„è§’åº¦æ¥æ•´ä½“æŸ¥çœ‹ä½“ç³»å®ç°ã€‚

## åˆè€Œå¾¡ä¹‹

[hardware](../archive/spike_architecture.png)

@TODO æ¦‚æ‹¬æè¿°è¿™äº›ç±»ä¹‹é—´çš„è”ç³»å’Œæ–¹æ³•

